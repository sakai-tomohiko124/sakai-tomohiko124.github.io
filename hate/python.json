[
    {
      "用語名": "クラス (Class)",
      "意味": "オブジェクトの設計図。同じ種類のものをたくさん作るときの「型」のようなもの。例えば「犬」という設計図。",
      "サンプルコード": "class Dog:\n    pass"
    },
    {
      "用語名": "オブジェクト (Object)",
      "意味": "設計図（クラス）を元に作られた実体。",
      "サンプルコード": "pochi = Dog()\n# pochiはDogクラスから作られたオブジェクト"
    },
    {
      "用語名": "インスタンス (Instance)",
      "意味": "オブジェクトとほぼ同じ意味で使われる。クラスから作られた実体のこと。",
      "サンプルコード": "hachi = Dog()\n# hachiはDogクラスのインスタンス"
    },
    {
      "用語名": "インスタンス化 (Instantiation)",
      "意味": "クラスからインスタンス（オブジェクト）を作成すること。",
      "サンプルコード": "shiro = Dog()\n# Dogクラスをインスタンス化してshiroを作る"
    },
    {
      "用語名": "属性 (Attribute)",
      "意味": "オブジェクトが持つデータ（変数）のこと。「プロパティ」とも呼ばれる。犬の「名前」や「年齢」など。",
      "サンプルコード": "class Dog:\n    def __init__(self, name):\n        self.name = name # nameが属性\n\npochi = Dog(\"ポチ\")\nprint(pochi.name) # \"ポチ\"と表示"
    },
    {
      "用語名": "メソッド (Method)",
      "意味": "オブジェクトが持つ振る舞い（関数）のこと。犬の「吠える」や「走る」など。クラス内で定義された関数のこと。",
      "サンプルコード": "class Dog:\n    def bark(self): # barkがメソッド\n        print(\"ワン！\")\n\npochi = Dog()\npochi.bark() # \"ワン！\"と表示"
    },
    {
      "用語名": "self",
      "意味": "メソッドの中で使われる特別な変数で、インスタンス自身を指す。「自分自身」という意味。",
      "サンプルコード": "class Dog:\n    def __init__(self, name):\n        self.name = name # selfは作られたインスタンスを指す"
    },
    {
      "用語名": "コンストラクタ (Constructor)",
      "意味": "インスタンスが作られるときに、最初に自動で呼ばれる特別なメソッド。初期設定を行う。",
      "サンプルコード": "class Dog:\n    # これがコンストラクタ\n    def __init__(self, name):\n        self.name = name\n        print(f\"{self.name}が生まれました！\")"
    },
    {
      "用語名": "__init__",
      "意味": "Pythonにおけるコンストラクタの名前。",
      "サンプルコード": "class Dog:\n    def __init__(self, name):\n        self.name = name"
    },
    {
      "用語名": "インスタンス変数 (Instance Variable)",
      "意味": "インスタンスごとに持つ変数。`self.変数名` の形で定義される。各犬が持つ自分の名前など。",
      "サンプルコード": "class Dog:\n    def __init__(self, name):\n        self.name = name # インスタンス変数\n\npochi = Dog(\"ポチ\")\nhachi = Dog(\"ハチ\")"
    }
,
    {
      "用語名": "継承 (Inheritance)",
      "意味": "あるクラス（親）の属性やメソッドを、別のクラス（子）が引き継ぐ仕組み。コードの再利用性を高める。",
      "サンプルコード": "class Animal:\n    def eat(self):\n        print(\"食べる\")\n\nclass Dog(Animal): # Animalを継承\n    pass\n\npochi = Dog()\npochi.eat() # 親のメソッドが使える"
    },
    {
      "用語名": "親クラス (Parent Class)",
      "意味": "継承元となるクラス。「スーパークラス」「基底クラス」とも呼ばれる。",
      "サンプルコード": "class Animal: # 親クラス\n    pass"
    },
    {
      "用語名": "子クラス (Child Class)",
      "意味": "継承して作られた新しいクラス。「サブクラス」「派生クラス」とも呼ばれる。",
      "サンプルコード": "class Dog(Animal): # 子クラス\n    pass"
    },
    {
      "用語名": "is-a関係 (is-a relationship)",
      "意味": "「子クラスは親クラスの一種である」という関係。例えば「犬(Dog)は動物(Animal)の一種である」。",
      "サンプルコード": "pochi = Dog()\n# pochi is a Dog, pochi is an Animal."
    },
    {
      "用語名": "オーバーライド (Override)",
      "意味": "親クラスのメソッドを、子クラスで同じ名前で再定義（上書き）すること。",
      "サンプルコード": "class Animal:\n    def cry(self):\n        print(\"...\")\n\nclass Dog(Animal):\n    def cry(self): # cryメソッドをオーバーライド\n        print(\"ワン！\")\n\npochi = Dog()\npochi.cry() # \"ワン！\"と表示"
    },
    {
      "用語名": "super()",
      "意味": "子クラスから親クラスのメソッドを呼び出すための関数。オーバーライドした上で、親の動きも使いたいときに便利。",
      "サンプルコード": "class Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name) # 親の__init__を呼び出す\n        self.breed = breed"
    },
    {
      "用語名": "多重継承 (Multiple Inheritance)",
      "意味": "複数の親クラスから継承すること。",
      "サンプルコード": "class Father:\n    def work(self):\n        print(\"会社で働く\")\n\nclass Mother:\n    def cook(self):\n        print(\"料理をする\")\n\nclass Child(Father, Mother): # 多重継承\n    pass"
    },
    {
      "用語名": "MRO (Method Resolution Order)",
      "意味": "メソッド解決順序。多重継承で同じ名前のメソッドがあった場合に、どの親クラスのものを優先して呼び出すかの順番。",
      "サンプルコード": "print(Child.mro())\n# [<class '__main__.Child'>, <class '__main__.Father'>, ...]"
    },
    {
      "用語名": "isinstance()",
      "意味": "あるオブジェクトが、特定のクラスのインスタンスかどうかを調べる関数。",
      "サンプルコード": "pochi = Dog()\nprint(isinstance(pochi, Dog)) # True\nprint(isinstance(pochi, Animal)) # True"
    },
    {
      "用語名": "issubclass()",
      "意味": "あるクラスが、特定のクラスの子クラス（サブクラス）かどうかを調べる関数。",
      "サンプルコード": "print(issubclass(Dog, Animal)) # True\nprint(issubclass(Animal, Dog)) # False"
    }
,
    {
      "用語名": "カプセル化 (Encapsulation)",
      "意味": "データ（属性）とそれを操作する手続き（メソッド）を一つにまとめ、外部から直接データを触られないように隠すこと。",
      "サンプルコード": "class Person:\n    def __init__(self, name):\n        self.__name = name # 外部から隠す\n\n    def get_name(self):\n        return self.__name"
    },
    {
      "用語名": "public",
      "意味": "クラスの外部から自由にアクセスできる属性やメソッド。Pythonでは特に何もしなければpublicになる。",
      "サンプルコード": "class MyClass:\n    def __init__(self):\n        self.public_var = \"OK\""
    },
    {
      "用語名": "protected",
      "意味": "「子クラスからはアクセスして良いが、全くの外部からはアクセスしないでほしい」という意思表示。変数名の先頭にアンダースコア(`_`)を1つ付ける。",
      "サンプルコード": "class MyClass:\n    def __init__(self):\n        self._protected_var = \"Protected\""
    },
    {
      "用語名": "private",
      "意味": "クラスの内部からしかアクセスできないようにする仕組み。変数名の先頭にアンダースコア(`__`)を2つ付ける。",
      "サンプルコード": "class MyClass:\n    def __init__(self):\n        self.__private_var = \"Private\""
    },
    {
      "用語名": "名前マングリング",
      "意味": "private変数(`__変数名`)が、外部からアクセスできないようにPythonが内部で名前を自動的に変更する仕組み。",
      "サンプルコード": "obj = MyClass()\n# obj.__private_var ではアクセスできない\n# obj._MyClass__private_var でアクセス可能"
    },
    {
      "用語名": "ゲッター (Getter)",
      "意味": "privateな属性の値を取得するためのメソッド。",
      "サンプルコード": "class Person:\n    def __init__(self, name):\n        self.__name = name\n\n    def get_name(self): # ゲッター\n        return self.__name"
    },
    {
      "用語名": "セッター (Setter)",
      "意味": "privateな属性に値を設定するためのメソッド。不正な値が設定されないようにチェックもできる。",
      "サンプルコード": "class Person:\n    def __init__(self, age):\n        self.__age = age\n\n    def set_age(self, age): # セッター\n        if age > 0:\n            self.__age = age"
    },
    {
      "用語名": "@property",
      "意味": "メソッドを属性のように呼び出せるようにするデコレータ。ゲッターを簡単に書くための仕組み。",
      "サンプルコード": "class Person:\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self): # メソッドだが()なしで呼べる\n        return self.__name\n\np = Person(\"Taro\")\nprint(p.name)"
    },
    {
      "用語名": "has-a関係 (has-a relationship)",
      "意味": "「あるクラスが、別のクラスのオブジェクトを部品として持っている」という関係。コンポジションとも呼ばれる。例:「車(Car)はエンジン(Engine)を持っている」。",
      "サンプルコード": "class Engine:\n    pass\n\nclass Car:\n    def __init__(self):\n        self.engine = Engine() # CarがEngineを持っている"
    },
    {
      "用語名": "デコレータ (Decorator)",
      "意味": "`@`から始まる記号で、関数やメソッドに特別な機能を追加するもの。",
      "サンプルコード": "@property\n@classmethod\n@staticmethod"
    },
    {
      "用語名": "多態性 (Polymorphism)",
      "意味": "ポリモーフィズムとも。同じ名前のメソッドでも、オブジェクトの種類によって異なる動作をすること。",
      "サンプルコード": "class Dog:\n    def cry(self): print(\"ワン\")\nclass Cat:\n    def cry(self): print(\"ニャー\")\n\nfor animal in [Dog(), Cat()]:\n    animal.cry() # 同じcry()でも結果が違う"
    },
    {
      "用語名": "ダックタイピング",
      "意味": "「アヒルのように歩き、アヒルのように鳴くなら、それはアヒルである」という考え方。オブジェクトの型が何であるかより、どんな振る舞い（メソッド）を持つかを重視する。",
      "サンプルコード": "class Person:\n    def cry(self): print(\"オギャー\")\n\nfor creature in [Dog(), Cat(), Person()]:\n    creature.cry()"
    },
    {
      "用語名": "クラス変数 (Class Variable)",
      "意味": "そのクラスの全インスタンスで共有される変数。インスタンス変数(`self.変数名`)とは異なり、クラスに直接属する。",
      "サンプルコード": "class Dog:\n    num_of_dogs = 0 # クラス変数\n\n    def __init__(self):\n        Dog.num_of_dogs += 1\n\nd1 = Dog()\nd2 = Dog()\nprint(Dog.num_of_dogs) # 2"
    },
    {
      "用語名": "クラスメソッド (Class Method)",
      "意味": "インスタンスを作らなくても、クラスから直接呼び出せるメソッド。第1引数にはクラス自身(`cls`)を取る。",
      "サンプルコード": "class Dog:\n    num_of_dogs = 0\n\n    @classmethod\n    def get_count(cls):\n        return cls.num_of_dogs\n\nprint(Dog.get_count()) # 0"
    },
    {
      "用語名": "@classmethod",
      "意味": "クラスメソッドを作るためのデコレータ。",
      "サンプルコード": "@classmethod\ndef my_method(cls):\n    pass"
    },
    {
      "用語名": "静的メソッド (Static Method)",
      "意味": "インスタンスの情報(`self`)もクラスの情報(`cls`)も使わない、クラスに属するただの関数。",
      "サンプルコード": "class MyMath:\n    @staticmethod\n    def add(a, b):\n        return a + b\n\nprint(MyMath.add(5, 3)) # 8"
    },
    {
      "用語名": "@staticmethod",
      "意味": "静的メソッドを作るためのデコレータ。",
      "サンプルコード": "@staticmethod\ndef my_function(arg1, arg2):\n    pass"
    },
    {
      "用語名": "__str__",
      "意味": "`print()`関数などでオブジェクトを人間が見やすい文字列として表示したいときに呼ばれる特殊メソッド。",
      "サンプルコード": "class Person:\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f\"私の名前は{self.name}です。\"\n\np = Person(\"Taro\")\nprint(p) # \"私の名前はTaroです。\""
    },
    {
      "用語名": "__repr__",
      "意味": "オブジェクトを開発者がデバッグなどで確認しやすい公式な文字列で表現したいときに呼ばれる特殊メソッド。",
      "サンプルコード": "class Person:\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return f'Person(\"{self.name}\")'\n\np = Person(\"Taro\")\nprint(repr(p)) # 'Person(\"Taro\")'"
    },
    {
      "用語名": "デストラクタ (Destructor)",
      "意味": "インスタンスがメモリから削除されるときに自動的に呼ばれるメソッド。後片付け処理などを書く。",
      "サンプルコード": "class MyClass:\n    def __del__(self):\n        print(\"インスタンスが削除されました\")"
    }
,
    {
      "用語名": "__del__",
      "意味": "Pythonにおけるデストラクタの名前。",
      "サンプルコード": "c = MyClass()\ndel c # \"インスタンスが削除されました\"と表示"
    },
    {
      "用語名": "抽象クラス (Abstract Class)",
      "意味": "設計図としての役割に特化したクラスで、インスタンスを作成できない。継承されることを前提とする。",
      "サンプルコード": "from abc import ABC, abstractmethod\n\nclass Animal(ABC): # 抽象クラス\n    @abstractmethod\n    def cry(self):\n        pass"
    },
    {
      "用語名": "抽象メソッド (Abstract Method)",
      "意味": "抽象クラス内で定義される、中身（実装）がないメソッド。子クラスで必ずオーバーライド（実装）しなければならないというルールを課す。",
      "サンプルコード": "class Animal(ABC):\n    @abstractmethod # 抽象メソッド\n    def cry(self):\n        pass"
    },
    {
      "用語名": "abc モジュール",
      "意味": "抽象クラス(ABC)と抽象メソッド(@abstractmethod)を使うためにインポートするモジュール。",
      "サンプルコード": "from abc import ABC, abstractmethod"
    },
    {
      "用語名": "@abstractmethod",
      "意味": "抽象メソッドを作るためのデコレータ。",
      "サンプルコード": "@abstractmethod\ndef my_method(self):\n    pass"
    },
    {
      "用語名": "イテレータ (Iterator)",
      "意味": "`for`ループで順番に値を取り出せるオブジェクトのこと。`__next__`メソッドを持つ。",
      "サンプルコード": "my_list = [1, 2, 3]\nit = iter(my_list) # イテレータを取得\nprint(next(it)) # 1\nprint(next(it)) # 2"
    },
    {
      "用語名": "__iter__",
      "意味": "`for`文などで使われるときに、イテレータを返す特殊メソッド。",
      "サンプルコード": "class MyNumbers:\n    def __iter__(self):\n        self.a = 1\n        return self"
    },
    {
      "用語名": "__next__",
      "意味": "`for`文などで、次の要素を取り出すときに呼ばれる特殊メソッド。",
      "サンプルコード": "class MyNumbers:\n    # ... __iter__に続けて ...\n    def __next__(self):\n        x = self.a\n        self.a += 1\n        return x"
    },
    {
      "用語名": "ミックスイン (Mixin)",
      "意味": "特定の機能だけを提供し、多重継承で様々なクラスに機能を追加（混ぜ込む）ために使われるクラス。",
      "サンプルコード": "class FlyableMixin:\n    def fly(self):\n        print(\"飛ぶ\")\n\nclass Bird(FlyableMixin, Animal):\n    pass"
    },
    {
      "用語名": "dataclass",
      "意味": "`__init__`や`__repr__`などを自動で生成してくれるデコレータ。主にデータを保持するだけのクラスを簡単に作るために使う。",
      "サンプルコード": "from dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\np = Person(\"Jiro\", 20)\nprint(p) # Person(name='Jiro', age=20)"
    }
    ,
    
    {
      "用語名": "スコープ (Scope)",
      "意味": "変数が「見える範囲」または「有効な範囲」のこと。プログラムのどの場所からその変数にアクセスできるかを示すルール。",
      "サンプルコード": "def my_func():\n    x = 10 # このxはmy_funcの中だけで有効（ローカルスコープ）\n    print(x)\n\nmy_func()\n# print(x) # ここからは見えないのでエラーになる"
    },
    {
      "用語名": "ネームスペース (Namespace)",
      "意味": "名前（変数名、関数名など）を管理するための辞書のような仕組み。スコープごとに独立したネームスペースが存在する。",
      "サンプルコード": "# Pythonは内部的にこんなイメージで名前を管理している\n# global_namespace = {'my_variable': 100}\n# local_namespace = {'x': 10}"
    },
    {
      "用語名": "ローカルスコープ (Local Scope)",
      "意味": "関数の中など、限定された範囲のスコープ。その中で定義された変数は、その範囲の外からはアクセスできない。",
      "サンプルコード": "def func():\n    animal = 'cat' # animalはローカルスコープ\n    print(animal)\n\nfunc()"
    },
    {
      "用語名": "グローバルスコープ (Global Scope)",
      "意味": "プログラム全体からアクセスできる最も外側のスコープ。モジュール（ファイル）レベルで定義された変数が属する。",
      "サンプルコード": "player_hp = 100 # グローバルスコープ\n\ndef show_hp():\n    print(player_hp) # どこからでも参照できる\n\nshow_hp()"
    },
    {
      "用語名": "エンクロージングスコープ (Enclosing Scope)",
      "意味": "関数の中に関数が定義されている（入れ子になっている）場合の、外側の関数のスコープ。内側の関数から見て「一つ外の」範囲。",
      "サンプルコード": "def outer():\n    x = 'outer' # エンクロージングスコープの変数\n    def inner():\n        print(x) # 内側から外側を参照できる\n    inner()\n\nouter()"
    },
    {
      "用語名": "ビルトインスコープ (Built-in Scope)",
      "意味": "Pythonに最初から組み込まれている関数（print()やlen()など）が属する、最も広いスコープ。意識しなくてもどこからでも使える。",
      "サンプルコード": "# print()はビルトインスコープに存在する\nprint('Hello')\n\n# len()も同様\nprint(len('world'))"
    },
    {
      "用語名": "LEGBルール",
      "意味": "Pythonが変数を探す順番のルール。Local → Enclosing → Global → Built-in の順に探していく。",
      "サンプルコード": "x = 'Global'\ndef outer():\n    x = 'Enclosing'\n    def inner():\n        # x = 'Local'\n        print(x) # LocalになければEnclosingを探しに行く\n    inner()\n\nouter() # 'Enclosing'と表示される"
    },
    {
      "用語名": "生存期間 (Lifetime)",
      "意味": "変数がメモリ上に存在している期間のこと。ローカル変数は関数が終了すると消えるが、グローバル変数はプログラム終了まで存在する。",
      "サンプルコード": "def func():\n    message = 'Hi' # funcの実行中だけ存在する\n\nfunc() # この行が終わるとmessageは消える"
    },
    {
      "用語名": "名前の束縛 (Name Binding)",
      "意味": "変数名とオブジェクト（値）を関連付けること。代入文（=）が使われると、そのスコープで名前の束縛が行われる。",
      "サンプルコード": "x = 10 # 'x'という名前を、数値オブジェクト'10'に束縛する"
    },
    {
      "用語名": "スコープ解決 (Scope Resolution)",
      "意味": "プログラムがLEGBルールに従って、使われている変数がどのスコープに属するものかを特定するプロセス。",
      "サンプルコード": "x = 10\ndef func():\n    print(x) # Pythonはここでxがグローバルスコープの変数だと解決する"
    }
,
    {
      "用語名": "変数 (Variable)",
      "意味": "データを格納しておくための「箱」のようなもの。名前を付けて値を保存し、後から参照したり変更したりできる。",
      "サンプルコード": "my_name = 'Taro' # my_nameという変数に'Taro'という文字列を保存"
    },
    {
      "用語名": "ローカル変数 (Local Variable)",
      "意味": "ローカルスコープ（主に関数内）で定義された変数。その関数の外からは使えない。",
      "サンプルコード": "def my_func():\n    local_var = 10 # ローカル変数\n    return local_var"
    },
    {
      "用語名": "グローバル変数 (Global Variable)",
      "意味": "グローバルスコープで定義された変数。プログラムのどこからでもアクセスできる。",
      "サンプルコード": "global_var = 100 # グローバル変数\n\ndef print_global():\n    print(global_var)"
    },
    {
      "用語名": "ノンローカル変数 (Nonlocal Variable)",
      "意味": "入れ子になった関数のうち、ローカルスコープではないが、グローバルスコープでもない（つまりエンクロージングスコープにある）変数のこと。",
      "サンプルコード": "def outer():\n    count = 0 # ノンローカル変数\n    def inner():\n        # nonlocal count を使うと値を変更できる\n        print(count)\n    return inner"
    },
    {
      "用語名": "仮引数 (Parameter)",
      "意味": "関数を定義するときに、受け取る値を一時的に入れておくための変数。関数の入り口で待っている変数。",
      "サンプルコード": "def greet(name): # 'name'が仮引数\n    print(f'Hello, {name}')"
    },
    {
      "用語名": "実引数 (Argument)",
      "意味": "関数を呼び出すときに、実際に渡す値や変数のこと。",
      "サンプルコード": "greet('Alice') # 'Alice'が実引数"
    },
    {
      "用語名": "シャドーイング (Shadowing)",
      "意味": "内側のスコープで外側のスコープと同じ名前の変数を定義することで、外側の変数が「隠れて」見えなくなる現象。",
      "サンプルコード": "x = 10 # グローバル変数\n\ndef func():\n    x = 20 # ローカル変数（グローバルのxを隠す）\n    print(x) # 20と表示される\n\nfunc()\nprint(x) # 10と表示される"
    },
    {
      "用語名": "自由変数 (Free Variable)",
      "意味": "入れ子関数の中で使われているが、その関数自身の中では定義されていない変数のこと（エンクロージングスコープなどを参照している変数）。",
      "サンプルコード": "def outer():\n    x = 10 # 自由変数\n    def inner():\n        print(x) # innerにとってxは自由変数\n    inner()"
    },
    {
      "用語名": "モジュール (Module)",
      "意味": "Pythonのコードが書かれたファイル（.py）。各モジュールは自分自身のグローバルスコープを持っている。",
      "サンプルコード": "# my_module.py\nMY_CONST = 100\n\n# main.py\n# import my_module\n# print(my_module.MY_CONST)"
    },
    {
      "用語名": "再束縛 (Rebinding)",
      "意味": "一度オブジェクトに束縛された変数名を、別のオブジェクトに束縛し直すこと。",
      "サンプルコード": "x = 10\nprint(x)\nx = 'hello' # xを別のオブジェクトに再束縛\nprint(x)"
    }
,
    {
      "用語名": "global キーワード",
      "意味": "関数の中で、グローバルスコープにある変数を変更したいときに「この変数はグローバル変数ですよ」と宣言するためのキーワード。",
      "サンプルコード": "count = 0\n\ndef increment():\n    global count # グローバル変数のcountを操作する宣言\n    count += 1\n\nincrement()\nprint(count) # 1と表示される"
    },
    {
      "用語名": "nonlocal キーワード",
      "意味": "入れ子関数の中で、エンクロージングスコープ（一番近い外側の関数）の変数を変更したいときに使うキーワード。",
      "サンプルコード": "def outer():\n    count = 0\n    def inner():\n        nonlocal count # 外側の関数のcountを操作する宣言\n        count += 1\n        return count\n    return inner\n\ncounter = outer()\nprint(counter()) # 1\nprint(counter()) # 2"
    },
    {
      "用語名": "`def` ステートメント",
      "意味": "関数を定義するための命令。`def` を使うと、新しいローカルスコープが作られる。",
      "サンプルコード": "def create_scope():\n    # ここから新しいローカルスコープが始まる\n    x = 1\n    # ここでローカルスコープが終わる"
    },
    {
      "用語名": "`lambda` 式",
      "意味": "名前を付けずに小さな関数（無名関数）を作るための式。`lambda` も自分自身のローカルスコープを持つ。",
      "サンプルコード": "add = lambda a, b: a + b # aとbはlambdaのローカルスコープ\nprint(add(3, 5))"
    },
    {
      "用語名": "`class` ステートメント",
      "意味": "クラスを定義するための命令。`class` も新しいローカルスコープを作り、クラス変数やメソッドがそこに属する。",
      "サンプルコード": "class MyClass:\n    class_var = 10 # MyClassのローカルスコープ\n    def method(self):\n        pass"
    },
    {
      "用語名": "`import` ステートメント",
      "意味": "他のモジュールを読み込んで、その中の変数や関数を使えるようにする命令。読み込んだモジュール名も現在のスコープに追加される。",
      "サンプルコード": "import math # 'math'という名前がグローバルスコープに追加される\nprint(math.pi)"
    },
    {
      "用語名": "`for` ループ変数のスコープ",
      "意味": "Python 3.xでは、forループで使った変数はループが終わった後もそのスコープに残り、最後の値が保持される。",
      "サンプルコード": "for i in range(3):\n    print(i)\n\nprint(f'ループ終了後: {i}') # 2と表示される"
    },
    {
      "用語名": "リスト内包表記のスコープ",
      "意味": "Python 3.xでは、リスト内包表記は独自のスコープを持つため、中で使われた変数は外に影響を与えない。",
      "サンプルコード": "x = 'global'\nmy_list = [x for x in range(5)]\nprint(my_list) # [0, 1, 2, 3, 4]\nprint(x) # 'global' のまま影響されない"
    },
    {
      "用語名": "`with` ステートメント",
      "意味": "ファイルのオープンなど、後処理が必要な処理を安全に行うための構文。`with`自体は新しいスコープを作らない。",
      "サンプルコード": "with open('file.txt', 'w') as f:\n    f.write('hello')\n# fはwithの外でも（基本的には）参照できるが非推奨"
    },
    {
      "用語名": "NameError",
      "意味": "定義されていない（どのスコープにも見つからない）変数を使おうとしたときに発生するエラー。",
      "サンプルコード": "print(unknown_variable)\n# NameError: name 'unknown_variable' is not defined"
    }
,
    {
      "用語名": "クロージャ (Closure)",
      "意味": "入れ子関数で、外側の関数の変数（状態）を記憶したまま返される内側の関数のこと。外側の関数が終了した後でも、その変数を参照できる。",
      "サンプルコード": "def outer(text):\n    def inner():\n        print(text) # 外側の変数'text'を記憶している\n    return inner\n\nmy_func = outer('Hello')\nmy_func() # 'Hello'と表示される"
    },
    {
      "用語名": "高階関数 (Higher-Order Function)",
      "意味": "「関数を引数として受け取る」または「関数を戻り値として返す」ことができる関数のこと。",
      "サンプルコード": "def greet(func):\n    func('Taro')\n\ndef say_hello(name):\n    print(f'Hello, {name}')\n\ngreet(say_hello) # 関数を引数として渡す"
    },
    {
      "用語名": "デコレータ (Decorator)",
      "意味": "既存の関数に新しい機能を追加するための仕組み。クロージャと高階関数の応用例。`@` を使って記述する。",
      "サンプルコード": "def my_decorator(func):\n    def wrapper():\n        print('---開始---')\n        func()\n        print('---終了---')\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print('こんにちは')"
    },
    {
      "用語名": "ファクトリ関数 (Factory Function)",
      "意味": "オブジェクトや関数を生成して返す関数のこと。クロージャを使って、設定の異なる関数を複数作りたいときなどに使われる。",
      "サンプルコード": "def multiplier_factory(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ntimes3 = multiplier_factory(3)\nprint(times3(5)) # 15"
    },
    {
      "用語名": "`globals()` 関数",
      "意味": "グローバルスコープのネームスペース（変数名と値のペア）を辞書として返す組み込み関数。",
      "サンプルコード": "x = 10\nprint(globals()['x']) # 10"
    },
    {
      "用語名": "`locals()` 関数",
      "意味": "現在のローカルスコープのネームスペースを辞書として返す組み込み関数。",
      "サンプルコード": "def func():\n    y = 20\n    print(locals()) # {'y': 20}と表示される\n\nfunc()"
    },
    {
      "用語名": "`vars()` 関数",
      "意味": "引数なしで呼ぶと`locals()`と同じ働きをする。オブジェクトを引数に渡すと、そのオブジェクトの属性を辞書として返す。",
      "サンプルコード": "class Person: pass\np = Person()\np.name = 'Taro'\nprint(vars(p)) # {'name': 'Taro'}"
    },
    {
      "用語名": "UnboundLocalError",
      "意味": "ローカルスコープ内で、代入より前に変数を参照しようとしたときに発生するエラー。Pythonがその変数をローカル変数だと判断した場合に起こる。",
      "サンプルコード": "x = 10\ndef func():\n    # print(x) # この行があるとエラー\n    x = 20\n# func() # UnboundLocalError"
    },
    {
      "用語名": "第一級オブジェクトとしての関数",
      "意味": "Pythonでは、関数を変数に代入したり、引数として渡したり、戻り値にしたりできる。数値や文字列と同じように扱えるということ。",
      "サンプルコード": "def hello():\n    print('Hello')\n\nai_satsu = hello # 変数に関数を代入\nai_satsu()"
    },
    {
      "用語名": "再帰関数 (Recursive Function)",
      "意味": "関数の中で自分自身の関数を呼び出すこと。呼び出されるたびに新しいローカルスコープが作られる。",
      "サンプルコード": "def countdown(n):\n    if n <= 0:\n        return\n    print(n)\n    countdown(n - 1)\n\ncountdown(3)"
    }
,
    {
      "用語名": "静的スコープ (Static Scoping)",
      "意味": "変数のスコープが、コードが書かれた場所（字句的な構造）によって決まるルール。Pythonはこのルールを採用している。「字句スコープ(Lexical Scoping)」とも呼ばれる。",
      "サンプルコード": "x = 10\ndef func():\n    print(x) # コードの構造上、外側のxが見える\n\nfunc()"
    },
    {
      "用語名": "ミュータブルなオブジェクトとスコープ",
      "意味": "リストや辞書など、中身を変更できるオブジェクト（ミュータブル）は、`global`などがなくても、関数内でその中身を変更できてしまうので注意が必要。",
      "サンプルコード": "my_list = [1, 2]\n\ndef add_item():\n    # global宣言なしで中身を変更できる\n    my_list.append(3)\n\nadd_item()\nprint(my_list) # [1, 2, 3]"
    },
    {
      "用語名": "イミュータブルなオブジェクトとスコープ",
      "意味": "数値、文字列、タプルなど、中身を変更できないオブジェクト（イミュータブル）を関数内で変更しようとすると、新しいオブジェクトが作られ、再束縛が起こる。",
      "サンプルコード": "x = 10\ndef func():\n    # x += 1 # これは x = x + 1 と同じ。globalがないとエラー\n    pass"
    },
    {
      "用語名": "`__main__`",
      "意味": "Pythonスクリプトが直接実行されたとき、そのスクリプトのモジュール名が自動的に設定される特別な名前。",
      "サンプルコード": "if __name__ == '__main__':\n    # このファイルが直接実行された時だけ動くコード\n    print('This is main script.')"
    },
    {
      "用語名": "`__name__`",
      "意味": "モジュールの名前を保持している特別な変数。直接実行された場合は `__main__` になり、importされた場合はそのモジュール名（ファイル名）になる。",
      "サンプルコード": "# my_module.py\n# print(f'my_moduleの__name__は: {__name__}')\n# \n# main.py で import my_module すると\n# 'my_moduleの__name__は: my_module'と表示"
    },
    {
      "用語名": "`__builtins__`",
      "意味": "ビルトインスコープのネームスペースにアクセスするための変数。通常は直接触る必要はない。",
      "サンプルコード": "# print関数は実際にはここにいる\n# __builtins__.print('Hello')"
    },
    {
      "用語名": "ジェネレータ式のスコープ",
      "意味": "`(x for x in iterable)` のようなジェネレータ式は、最初の`for`句の変数が外側のスコープに漏れることがある（Python 2からの名残）。",
      "サンプルコード": "x = 'global'\ngen = (x for x in range(5))\nprint(x) # Python 3でも'global'のまま（内包表記と挙動が統一）"
    },
    {
      "用語名": "`try...except` とスコープ",
      "意味": "`except Exception as e:` で補足した例外オブジェクト`e`は、`except`ブロックが終わると（Python 3.xでは）削除される。",
      "サンプルコード": "try:\n    1 / 0\nexcept ZeroDivisionError as e:\n    print(e)\n# print(e) # ここではNameErrorになる"
    },
    {
      "用語名": "カプセル化 (Encapsulation)",
      "意味": "オブジェクト指向の考え方で、データ（属性）と手続き（メソッド）を一つにまとめ、スコープをクラス内に限定して外部から隠すこと。",
      "サンプルコード": "class Person:\n    def __init__(self, name):\n        self.__name = name # 外部から直接見えないようにする"
    },
    {
      "用語名": "副作用 (Side Effect)",
      "意味": "関数が戻り値を返すだけでなく、グローバル変数を変更するなど、関数の外側の状態を変化させてしまうこと。副作用が多すぎるとプログラムが複雑になる。",
      "サンプルコード": "count = 0\ndef increment_with_side_effect():\n    global count\n    count += 1 # グローバル変数を変更する副作用\n    return count"
    },

    {
      "用語名": "データ構造 (Data Structure)",
      "意味": "プログラムで複数のデータを効率的に扱うための「入れ物」や「仕組み」のこと。リスト、タプル、辞書、集合などがある。",
      "サンプルコード": "my_list = [1, 2, 3] # リストというデータ構造\nmy_dict = {'name': 'Taro'} # 辞書というデータ構造"
    },
    {
      "用語名": "コレクション (Collection)",
      "意味": "複数の要素（値）をまとめて格納できるデータ型のこと。Pythonのリスト、タプル、辞書、集合はすべてコレクション。",
      "サンプルコード": "# これらはすべてコレクション\ndata1 = [1, 2]\ndata2 = (3, 4)\ndata3 = {'a': 5}\ndata4 = {6, 7}"
    },
    {
      "用語名": "イテラブル (Iterable)",
      "意味": "forループなどで、要素を一つずつ順番に取り出すことができるオブジェクトのこと。リスト、タプル、辞書、集合、文字列などが該当する。",
      "サンプルコード": "for char in 'hello': # 文字列はイテラブル\n    print(char)"
    },
    {
      "用語名": "シーケンス (Sequence)",
      "意味": "要素が順序付けられて格納されているイテラブルのこと。インデックス（番号）で要素にアクセスできる。リスト、タプル、文字列が代表的。",
      "サンプルコード": "my_list = ['a', 'b', 'c']\nprint(my_list[0]) # 'a' (インデックスでアクセス)"
    },
    {
      "用語名": "ミュータブル (Mutable)",
      "意味": "「変更可能」という意味。オブジェクトを作成した後に、その中身（要素）を変更できる性質のこと。リスト、辞書、集合が該当する。",
      "サンプルコード": "my_list = [1, 2, 3]\nmy_list[0] = 100 # 中身を変更できる\nprint(my_list) # [100, 2, 3]"
    },
    {
      "用語名": "イミュータブル (Immutable)",
      "意味": "「変更不可能」という意味。オブジェクトを作成した後に、その中身を変更できない性質のこと。タプル、文字列、数値が該当する。",
      "サンプルコード": "my_tuple = (1, 2, 3)\n# my_tuple[0] = 100 # エラーになる (TypeError)"
    },
    {
      "用語名": "インデックス (Index)",
      "意味": "シーケンス内の各要素に割り振られた、0から始まる「住所番号」のこと。要素を指定する際に使う。",
      "サンプルコード": "fruits = ['apple', 'banana', 'cherry']\n# 'apple'のインデックスは0\n# 'banana'のインデックスは1"
    },
    {
      "用語名": "スライス (Slice)",
      "意味": "シーケンスから、一部分を範囲指定して切り出す操作のこと。`[開始:終了]` のように書く。",
      "サンプルコード": "numbers = [0, 1, 2, 3, 4, 5]\nprint(numbers[1:4]) # [1, 2, 3] (1番目から4番目の直前まで)"
    },
    {
      "用語名": "ネスト (Nest)",
      "意味": "「入れ子」のこと。データ構造の中に、さらにデータ構造を入れること。多次元のデータを表現できる。",
      "サンプルコード": "nested_list = [[1, 2], [3, 4]]\nprint(nested_list[0][1]) # 2"
    },
    {
      "用語名": "要素 (Element)",
      "意味": "データ構造に含まれている個々のデータのこと。「アイテム」とも呼ばれる。",
      "サンプルコード": "my_list = ['a', 'b', 'c']\n# 'a', 'b', 'c'が要素"
    }
,
    {
      "用語名": "リスト (List)",
      "意味": "複数の要素を順序付けて格納できる、変更可能（ミュータブル）なデータ構造。角括弧 `[]` を使って作る。",
      "サンプルコード": "scores = [80, 95, 72]\nnames = ['Taro', 'Jiro', 'Saburo']"
    },
    {
      "用語名": "`append()` メソッド",
      "意味": "リストの末尾に新しい要素を1つ追加する。",
      "サンプルコード": "colors = ['red', 'blue']\ncolors.append('green')\nprint(colors) # ['red', 'blue', 'green']"
    },
    {
      "用語名": "`insert()` メソッド",
      "意味": "リストの指定したインデックスの位置に要素を挿入する。",
      "サンプルコード": "colors = ['red', 'green']\ncolors.insert(1, 'blue') # 1番目の位置に挿入\nprint(colors) # ['red', 'blue', 'green']"
    },
    {
      "用語名": "`pop()` メソッド",
      "意味": "指定したインデックスの要素を取り出し、リストから削除する。インデックスを省略すると末尾の要素を取り出す。",
      "サンプルコード": "colors = ['red', 'blue', 'green']\npopped_color = colors.pop(1)\nprint(popped_color) # 'blue'\nprint(colors) # ['red', 'green']"
    },
    {
      "用語名": "`remove()` メソッド",
      "意味": "リストの中から、指定した値と最初に一致した要素を削除する。",
      "サンプルコード": "colors = ['red', 'blue', 'green', 'blue']\ncolors.remove('blue')\nprint(colors) # ['red', 'green', 'blue']"
    },
    {
      "用語名": "`sort()` メソッド",
      "意味": "リストの要素を並べ替える。元のリスト自体が変更される（インプレースな操作）。",
      "サンプルコード": "numbers = [3, 1, 4, 2]\nnumbers.sort()\nprint(numbers) # [1, 2, 3, 4]"
    },
    {
      "用語名": "`sorted()` 関数",
      "意味": "リストや他のイテラブルを並べ替えた、新しいリストを返す。元のデータは変更されない。",
      "サンプルコード": "numbers = [3, 1, 4, 2]\nnew_list = sorted(numbers)\nprint(new_list) # [1, 2, 3, 4]\nprint(numbers) # [3, 1, 4, 2]"
    },
    {
      "用語名": "リスト内包表記 (List Comprehension)",
      "意味": "既存のリストやイテラブルから、新しいリストを簡潔に作るための書き方。",
      "サンプルコード": "# 0から4までの数値を2乗したリストを作る\nsquares = [x**2 for x in range(5)]\nprint(squares) # [0, 1, 4, 9, 16]"
    }
,
    {
      "用語名": "タプル (Tuple)",
      "意味": "複数の要素を順序付けて格納できる、変更不可能（イミュータブル）なデータ構造。丸括弧 `()` を使って作る。",
      "サンプルコード": "point = (10, 20)\nweekdays = ('Mon', 'Tue', 'Wed')"
    },
    {
      "用語名": "アンパッキング (Unpacking)",
      "意味": "タプルやリストの要素を、一度に複数の変数に代入すること。「パックされたものを解く」イメージ。",
      "サンプルコード": "point = (10, 20)\nx, y = point # アンパッキング\nprint(x) # 10\nprint(y) # 20"
    },
    {
      "用語名": "単要素タプル",
      "意味": "要素が1つだけのタプル。値の後ろにカンマ `,` を付けないと、ただの括弧付きの値とみなされてしまうので注意が必要。",
      "サンプルコード": "t1 = (50) # これはタプルではなく、ただの整数50\nt2 = (50,) # これが単要素タプル\nprint(type(t1)) # <class 'int'>\nprint(type(t2)) # <class 'tuple'>"
    },
    {
      "用語名": "タプルの利点",
      "意味": "変更されたくない定数的なデータをまとめたり、辞書のキーとして使えたりする（リストはキーにできない）。",
      "サンプルコード": "locations = {(35.6, 139.6): 'Tokyo'}\n# locations = {[35.6, 139.6]: 'Tokyo'} # エラーになる"
    }
,
    {
      "用語名": "辞書 (Dictionary / dict)",
      "意味": "キー(Key)と値(Value)をペアで格納するデータ構造。順序は保証されない（Python 3.7+では挿入順が保持される）。波括弧 `{}` で作る。",
      "サンプルコード": "user = {'name': 'Taro', 'age': 20}\nprint(user['name']) # 'Taro'"
    },
    {
      "用語名": "キー (Key)",
      "意味": "辞書の中で、値を一意に特定するための「見出し」や「ラベル」。キーは変更不可能（イミュータブル）なオブジェクトでなければならない。",
      "サンプルコード": "user = {'name': 'Taro'}\n# 'name'がキー"
    },
    {
      "用語名": "値 (Value)",
      "意味": "キーに対応して格納されているデータ。値にはどんなオブジェクトでも使える。",
      "サンプルコード": "user = {'name': 'Taro'}\n# 'Taro'が値"
    },
    {
      "用語名": "キーと値のペア (Key-Value Pair)",
      "意味": "辞書を構成する、キーと値の1組の組み合わせのこと。",
      "サンプルコード": "# 'name': 'Taro' が1つのキーと値のペア"
    },
    {
      "用語名": "ハッシュ可能 (Hashable)",
      "意味": "オブジェクトが「ハッシュ値」という固定の数値を計算でき、かつ変更不可能であること。辞書のキーになるための条件。",
      "サンプルコード": "# 文字列、数値、タプルはハッシュ可能\n# リスト、辞書はハッシュ不可能"
    },
    {
      "用語名": "`get()` メソッド",
      "意味": "キーを指定して値を取得する。キーが存在しない場合にエラーにならず、Noneや指定したデフォルト値を返す。",
      "サンプルコード": "user = {'name': 'Taro'}\nprint(user.get('age')) # None\nprint(user.get('age', '不明')) # '不明'"
    },
    {
      "用語名": "`keys()` メソッド",
      "意味": "辞書のすべてのキーを一覧で取得する。",
      "サンプルコード": "user = {'name': 'Taro', 'age': 20}\nprint(user.keys()) # dict_keys(['name', 'age'])"
    },
    {
      "用語名": "`values()` メソッド",
      "意味": "辞書のすべての値を一覧で取得する。",
      "サンプルコード": "user = {'name': 'Taro', 'age': 20}\nprint(user.values()) # dict_values(['Taro', 20])"
    },
    {
      "用語名": "`items()` メソッド",
      "意味": "辞書のすべてのキーと値のペアを、(キー, 値)のタプルの形で一覧で取得する。forループでよく使われる。",
      "サンプルコード": "user = {'name': 'Taro', 'age': 20}\nfor key, value in user.items():\n    print(f'{key}: {value}')"
    },
    {
      "用語名": "`update()` メソッド",
      "意味": "ある辞書を別の辞書の内容で更新する。キーが重複する場合は、新しい辞書の値で上書きされる。",
      "サンプルコード": "d1 = {'a': 1, 'b': 2}\nd2 = {'b': 20, 'c': 30}\nd1.update(d2)\nprint(d1) # {'a': 1, 'b': 20, 'c': 30}"
    },
    {
      "用語名": "辞書内包表記 (Dictionary Comprehension)",
      "意味": "リスト内包表記の辞書版。簡潔に辞書を生成できる。",
      "サンプルコード": "squares = {x: x**2 for x in range(5)}\nprint(squares) # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}"
    }
,
    {
      "用語名": "集合 (Set)",
      "意味": "重複する要素を持たず、順序もないデータ構造。数学の「集合」と同じような操作ができる。波括弧 `{}` で作るが、辞書と区別が必要。",
      "サンプルコード": "unique_numbers = {1, 2, 3, 2, 1}\nprint(unique_numbers) # {1, 2, 3} (重複が自動的に削除される)"
    },
    {
      "用語名": "空の集合の作り方",
      "意味": "`{}` と書くと空の辞書になってしまうため、空の集合は `set()` を使って作る。",
      "サンプルコード": "empty_dict = {}\nempty_set = set()\nprint(type(empty_dict)) # <class 'dict'>\nprint(type(empty_set)) # <class 'set'>"
    },
    {
      "用語名": "`add()` メソッド",
      "意味": "集合に新しい要素を1つ追加する。",
      "サンプルコード": "s = {1, 2}\ns.add(3)\nprint(s) # {1, 2, 3}"
    },
    {
      "用語名": "`discard()` メソッド",
      "意味": "集合から指定した要素を削除する。その要素が存在しなくてもエラーにならない。",
      "サンプルコード": "s = {1, 2, 3}\ns.discard(2)\ns.discard(99) # エラーにならない\nprint(s) # {1, 3}"
    },
    {
      "用語名": "和集合 (Union)",
      "意味": "2つの集合のすべての要素を合わせた集合。`|` 演算子または `union()` メソッドを使う。",
      "サンプルコード": "a = {1, 2, 3}\nb = {3, 4, 5}\nprint(a | b) # {1, 2, 3, 4, 5}"
    },
    {
      "用語名": "積集合 / 共通集合 (Intersection)",
      "意味": "2つの集合の両方に含まれる要素だけを集めた集合。`&` 演算子または `intersection()` メソッドを使う。",
      "サンプルコード": "a = {1, 2, 3}\nb = {3, 4, 5}\nprint(a & b) # {3}"
    },
    {
      "用語名": "差集合 (Difference)",
      "意味": "一方の集合にだけ含まれる要素（もう一方の集合に含まれる要素を取り除いたもの）の集合。`-` 演算子または `difference()` メソッドを使う。",
      "サンプルコード": "a = {1, 2, 3}\nb = {3, 4, 5}\nprint(a - b) # {1, 2}"
    },
    {
      "用語名": "対称差集合 (Symmetric Difference)",
      "意味": "どちらか一方の集合にだけ含まれる要素（両方に含まれる要素以外）の集合。`^` 演算子または `symmetric_difference()` メソッドを使う。",
      "サンプルコード": "a = {1, 2, 3}\nb = {3, 4, 5}\nprint(a ^ b) # {1, 2, 4, 5}"
    },
    {
      "用語名": "部分集合 (Subset)",
      "意味": "ある集合のすべての要素が、もう一方の集合に含まれている状態。`<=` 演算子で判定できる。",
      "サンプルコード": "a = {1, 2}\nb = {1, 2, 3}\nprint(a <= b) # True"
    },
    {
      "用語名": "上位集合 (Superset)",
      "意味": "ある集合が、もう一方の集合のすべての要素を含んでいる状態。`>=` 演算子で判定できる。",
      "サンプルコード": "a = {1, 2, 3}\nb = {1, 2}\nprint(a >= b) # True"
    },
    {
      "用語名": "集合内包表記 (Set Comprehension)",
      "意味": "リスト内包表記の集合版。簡潔に集合を生成できる。",
      "サンプルコード": "unique_squares = {x**2 for x in [1, -1, 2, -2]}\nprint(unique_squares) # {1, 4}"
    },
    {
      "用語名": "frozenset",
      "意味": "変更不可能（イミュータブル）な集合。要素を追加したり削除したりできない。辞書のキーや集合の要素として使える。",
      "サンプルコード": "fs = frozenset([1, 2, 3])\n# fs.add(4) # エラーになる\nmy_dict = {fs: 'my_frozen_set'}"
    },

    {
      "用語名": "文字列 (String)",
      "意味": "「こんにちは」や「abc」などの文字の並びのこと。Pythonではシングルクォート `' '` またはダブルクォート `\" \"` で囲んで表現する。",
      "サンプルコード": "s1 = 'Hello'\ns2 = \"World\""
    },
    {
      "用語名": "トリプルクォート",
      "意味": "シングルクォートまたはダブルクォートを3つ続けたもの (`'''` or `\"\"\"`)。複数行にわたる文字列を書くことができる。",
      "サンプルコード": "multi_line_string = '''\nこれは\n複数行の\n文字列です。\n'''\nprint(multi_line_string)"
    },
    {
      "用語名": "エスケープシーケンス",
      "意味": "文字列の中で特別な意味を持つ文字を表現するための書き方。例えば `\\n` は改行、 `\\t` はタブを表す。",
      "サンプルコード": "print('Hello\\nWorld')\n# Hello\n# World と表示される"
    },
    {
      "用語名": "raw文字列 (r-string)",
      "意味": "文字列の前に `r` を付けると、エスケープシーケンスを無効にして、書いたままの文字列として扱うことができる。",
      "サンプルコード": "print(r'C:\\Users\\Taro\\Desktop')\n# C:\\Users\\Taro\\Desktop とそのまま表示される"
    },
    {
      "用語名": "イミュータブル (Immutable)",
      "意味": "「変更不可能」という意味。文字列は一度作成すると、その中の一部分だけを書き換えることはできない。",
      "サンプルコード": "s = 'hello'\n# s[0] = 'H' # これはエラーになる (TypeError)"
    },
    {
      "用語名": "インデックス (Index)",
      "意味": "文字列内の各文字に割り振られた、0から始まる「住所番号」。文字を1つだけ取り出すときに使う。",
      "サンプルコード": "s = 'python'\nprint(s[0]) # 'p'\nprint(s[2]) # 't'"
    },
    {
      "用語名": "負のインデックス",
      "意味": "文字列の末尾から数えるインデックス。-1が最後の文字、-2が最後から2番目の文字を指す。",
      "サンプルコード": "s = 'python'\nprint(s[-1]) # 'n'\nprint(s[-2]) # 'o'"
    },
    {
      "用語名": "len() 関数",
      "意味": "文字列の長さ（文字数）を調べるための組み込み関数。",
      "サンプルコード": "s = 'python'\nprint(len(s)) # 6"
    }
,
    {
      "用語名": "スライス (Slice)",
      "意味": "文字列から、一部分を範囲指定して切り出す操作のこと。`[開始インデックス:終了インデックス]` のように書く。",
      "サンプルコード": "s = 'abcdefg'\nprint(s[1:4]) # 'bcd' (1番目から4番目の直前まで)"
    },
    {
      "用語名": "スライスの開始位置省略",
      "意味": "スライスの開始インデックスを省略すると、文字列の最初から切り出すことになる。",
      "サンプルコード": "s = 'abcdefg'\nprint(s[:3]) # 'abc' (最初から3番目の直前まで)"
    },
    {
      "用語名": "スライスの終了位置省略",
      "意味": "スライスの終了インデックスを省略すると、指定した位置から文字列の最後まで切り出すことになる。",
      "サンプルコード": "s = 'abcdefg'\nprint(s[2:]) # 'cdefg' (2番目から最後まで)"
    },
    {
      "用語名": "ステップ (Step)",
      "意味": "スライスで、何個おきに文字を取り出すかを指定するもの。`[開始:終了:ステップ]` のように書く。",
      "サンプルコード": "s = '0123456789'\nprint(s[::2]) # '02468' (最初から最後まで2個おき)"
    },
    {
      "用語名": "文字列の逆順",
      "意味": "スライスのステップに `-1` を指定すると、文字列を簡単に逆順にすることができる。",
      "サンプルコード": "s = 'python'\nprint(s[::-1]) # 'nohtyp'"
    }
,
    {
      "用語名": "+ 演算子 (結合)",
      "意味": "文字列同士を連結して、新しい1つの文字列を作る。",
      "サンプルコード": "s1 = 'Hello'\ns2 = 'World'\nprint(s1 + ' ' + s2) # 'Hello World'"
    },
    {
      "用語名": "* 演算子 (繰り返し)",
      "意味": "文字列を指定した回数だけ繰り返した、新しい文字列を作る。",
      "サンプルコード": "s = 'Hi! '\nprint(s * 3) # 'Hi! Hi! Hi! '"
    },
    {
      "用語名": "in 演算子 (メンバーシップ)",
      "意味": "ある文字列が、別の文字列の中に含まれているかどうかを調べる。含まれていれば `True`、いなければ `False` を返す。",
      "サンプルコード": "s = 'I like apple pie.'\nprint('apple' in s) # True\nprint('orange' in s) # False"
    },
    {
      "用語名": "upper() メソッド",
      "意味": "文字列をすべて大文字に変換した新しい文字列を返す。",
      "サンプルコード": "s = 'hello'\nprint(s.upper()) # 'HELLO'"
    },
    {
      "用語名": "lower() メソッド",
      "意味": "文字列をすべて小文字に変換した新しい文字列を返す。",
      "サンプルコード": "s = 'HELLO'\nprint(s.lower()) # 'hello'"
    },
    {
      "用語名": "replace() メソッド",
      "意味": "文字列の中の特定の部分を、別の文字列に置き換えた新しい文字列を返す。",
      "サンプルコード": "s = 'I like cats.'\nnew_s = s.replace('cats', 'dogs')\nprint(new_s) # 'I like dogs.'"
    },
    {
      "用語名": "split() メソッド",
      "意味": "文字列を、指定した区切り文字で分割し、リストとして返す。",
      "サンプルコード": "s = 'apple,banana,cherry'\nfruits = s.split(',')\nprint(fruits) # ['apple', 'banana', 'cherry']"
    },
    {
      "用語名": "join() メソッド",
      "意味": "リストなどの要素を、指定した文字列を区切り文字として連結し、1つの文字列を返す。`split()`の逆の操作。",
      "サンプルコード": "fruits = ['apple', 'banana', 'cherry']\ns = ', '.join(fruits)\nprint(s) # 'apple, banana, cherry'"
    },
    {
      "用語名": "strip() メソッド",
      "意味": "文字列の両端にある空白（スペースや改行）を取り除いた新しい文字列を返す。",
      "サンプルコード": "s = '   hello world   '\nprint(s.strip()) # 'hello world'"
    },
    {
      "用語名": "find() メソッド",
      "意味": "文字列の中から指定した文字列を検索し、最初に見つかった位置のインデックスを返す。見つからない場合は `-1` を返す。",
      "サンプルコード": "s = 'python'\nprint(s.find('th')) # 2\nprint(s.find('z')) # -1"
    },
    {
      "用語名": "startswith() メソッド",
      "意味": "文字列が、指定した文字列で始まっているかどうかを調べる。",
      "サンプルコード": "s = 'image.png'\nprint(s.startswith('image')) # True"
    },
    {
      "用語名": "endswith() メソッド",
      "意味": "文字列が、指定した文字列で終わっているかどうかを調べる。",
      "サンプルコード": "s = 'image.png'\nprint(s.endswith('.png')) # True"
    }
,
    {
      "用語名": "f-string (書式化文字列)",
      "意味": "文字列の前に `f` を付け、文字列中の `{}` の中に変数名や式を書くことで、簡単に値を埋め込める機能。",
      "サンプルコード": "name = 'Taro'\nage = 20\ns = f'私の名前は{name}です。年齢は{age}歳です。'\nprint(s)"
    },
    {
      "用語名": "format() メソッド",
      "意味": "文字列の `{}` の部分に、`format()`メソッドの引数で指定した値を埋め込む機能。f-stringが登場する前によく使われた。",
      "サンプルコード": "s = '名前: {}, 年齢: {}'.format('Jiro', 25)\nprint(s)"
    },
    {
      "用語名": "str() 関数",
      "意味": "数値などの他のデータ型を、文字列型に変換するための組み込み関数。",
      "サンプルコード": "age = 20\n# print('年齢は' + age + '歳です') # エラーになる\nprint('年齢は' + str(age) + '歳です')"
    }
,
    {
      "用語名": "算術演算子 (Arithmetic Operator)",
      "意味": "足し算(`+`)、引き算(`-`)、掛け算(`*`)、割り算(`/`)など、数学的な計算を行うための記号。",
      "サンプルコード": "x = 10\ny = 3\nprint(x + y) # 13\nprint(x / y) # 3.333..."
    },
    {
      "用語名": "// (切り捨て除算)",
      "意味": "割り算の答えの、小数点以下を切り捨てて整数部分だけを求める演算子。",
      "サンプルコード": "print(10 // 3) # 3"
    },
    {
      "用語名": "% (剰余演算子)",
      "意味": "割り算の「余り」を求める演算子。「mod (モッド)」とも呼ばれる。",
      "サンプルコード": "print(10 % 3) # 1 (10割る3は3余り1)"
    },
    {
      "用語名": "** (べき乗演算子)",
      "意味": "「〜乗」を計算する演算子。例えば `2 ** 3` は2の3乗を表す。",
      "サンプルコード": "print(2 ** 3) # 8 (2 * 2 * 2)\nprint(3 ** 2) # 9 (3 * 3)"
    },
    {
      "用語名": "比較演算子 (Comparison Operator)",
      "意味": "2つの値を比較し、その結果が正しいか(`True`)間違っているか(`False`)を返す演算子。",
      "サンプルコード": "age = 20\nprint(age >= 18) # True\nprint(age == 20) # True"
    },
    {
      "用語名": "== (等しい)",
      "意味": "左辺と右辺の値が等しいかどうかを調べる比較演算子。 `=` (代入) とは違うので注意。",
      "サンプルコード": "x = 10\nprint(x == 10) # True\nprint(x == 5) # False"
    },
    {
      "用語名": "!= (等しくない)",
      "意味": "左辺と右辺の値が等しくないかどうかを調べる比較演算子。",
      "サンプルコード": "x = 10\nprint(x != 5) # True\nprint(x != 10) # False"
    },
    {
      "用語名": "<, >, <=, >=",
      "意味": "値の大小関係を比較する演算子。小なり(`<`)、大なり(`>`)、小なりイコール(`<=`)、大なりイコール(`>=`)。",
      "サンプルコード": "score = 85\nprint(score > 80) # True\nprint(score <= 90) # True"
    },
    {
      "用語名": "代入演算子 (Assignment Operator)",
      "意味": "右辺の値を左辺の変数に保存（代入）するための演算子。 `=` が基本。",
      "サンプルコード": "my_name = 'Suzuki'"
    },
    {
      "用語名": "複合代入演算子",
      "意味": "計算と代入を同時に行う演算子。 `x = x + 1` を `x += 1` のように短く書ける。",
      "サンプルコード": "score = 10\nscore += 5 # score = score + 5 と同じ\nprint(score) # 15"
    },
    {
      "用語名": "論理演算子 (Logical Operator)",
      "意味": "複数の条件を組み合わせるための演算子。「かつ(`and`)」、「または(`or`)」、「〜ではない(`not`)」がある。",
      "サンプルコード": "age = 25\n# 20歳以上 かつ 30歳未満\nprint(age >= 20 and age < 30) # True"
    },
    {
      "用語名": "and",
      "意味": "「A かつ B」。AとBの両方の条件が `True` のときだけ、全体が `True` になる。",
      "サンプルコード": "x = 10\nprint(x > 0 and x < 20) # True"
    },
    {
      "用語名": "or",
      "意味": "「A または B」。AかBの少なくとも一方の条件が `True` であれば、全体が `True` になる。",
      "サンプルコード": "x = 50\nprint(x < 10 or x > 40) # True"
    },
    {
      "用語名": "not",
      "意味": "「〜ではない」。条件の結果(`True`/`False`)を反転させる。",
      "サンプルコード": "is_sunny = False\nprint(not is_sunny) # True"
    },
    {
      "用語名": "三項演算子 (Conditional Expression)",
      "意味": "if文を1行で簡潔に書くための書き方。「(Trueの場合の値) if (条件式) else (Falseの場合の値)」という形式。",
      "サンプルコード": "age = 20\nstatus = 'adult' if age >= 18 else 'child'\nprint(status) # 'adult'"
    },

    {
      "用語名": "条件分岐 (Conditional Branch)",
      "意味": "ある条件が満たされているかどうかによって、次に実行する処理を変えること。「もし〜ならA、そうでなければB」のように処理の流れを分ける。",
      "サンプルコード": "score = 80\nif score >= 60:\n    print('合格')\nelse:\n    print('不合格')"
    },
    {
      "用語名": "if 文",
      "意味": "「もし〜ならば」という条件分岐を作るための最も基本的な命令。指定した条件が正しい(True)場合だけ、続く処理ブロックを実行する。",
      "サンプルコード": "weather = 'sunny'\nif weather == 'sunny':\n    print('外で遊ぼう')"
    },
    {
      "用語名": "条件式 (Condition)",
      "意味": "結果が `True` (正しい)か `False` (間違い)のどちらかになる式のこと。`if`文や`while`文の `()` の中に書かれる。",
      "サンプルコード": "age = 20\n# age >= 18 の部分が条件式"
    },
    {
      "用語名": "else 文",
      "意味": "`if`文の条件が満たされなかった (`False`だった) 場合に実行される処理を書く部分。「そうでなければ」という意味。",
      "サンプルコード": "age = 15\nif age >= 20:\n    print('お酒が飲めます')\nelse:\n    print('お酒は飲めません')"
    },
    {
      "用語名": "elif 文",
      "意味": "`else if` の略。「最初の条件が間違いで、もしこちらの条件が正しいならば」のように、複数の条件を順番に試したいときに使う。",
      "サンプルコード": "score = 75\nif score >= 80:\n    print('優')\nelif score >= 60:\n    print('良')\nelse:\n    print('可')"
    },
    {
      "用語名": "真偽値 (Boolean)",
      "意味": "`True` (真) と `False` (偽) の2種類の値だけを持つデータ型。条件式の結果として使われる。",
      "サンプルコード": "is_active = True\nis_admin = False"
    },
    {
      "用語名": "インデント (Indentation)",
      "意味": "行の先頭にある空白（字下げ）のこと。Pythonでは、このインデントによって処理のまとまり（ブロック）を区別する、非常に重要なルール。",
      "サンプルコード": "if True:\n    print('この行はインデントされている')\n    print('同じブロックに属する')\nprint('この行はブロックの外')"
    },
    {
      "用語名": "ブロック (Block)",
      "意味": "`if`文や`for`文などに属する、ひとまとまりの処理。同じ深さのインデントを持つコードが同じブロックとみなされる。",
      "サンプルコード": "# 上記インデントのサンプルの、インデントされた2行が1つのブロック"
    },
    {
      "用語名": "ネスト (Nest)",
      "意味": "「入れ子」のこと。`if`文の中にさらに`if`文を書くなど、構文の中に同じ種類の構文を入れること。",
      "サンプルコード": "num = 10\nif num > 0:\n    print('正の数です')\n    if num % 2 == 0:\n        print('偶数です')"
    },
    {
      "用語名": "Truthiness (真理値判定)",
      "意味": "Pythonでは、数値の `0`、空の文字列 `''`、空のリスト `[]` などは `False` として扱われ、それ以外のほとんどの値は `True` として扱われるというルール。",
      "サンプルコード": "if 'hello':\n    print('文字列はTrueとして扱われる')\nif []:\n    print('この行は実行されない')"
    },
    {
      "用語名": "三項演算子",
      "意味": "`if-else`文を1行で簡潔に書くための書き方。「(Trueの場合の値) if (条件式) else (Falseの場合の値)」という形式。",
      "サンプルコード": "age = 20\nresult = '大人' if age >= 18 else '子供'\nprint(result)"
    }
,
    {
      "用語名": "繰り返し処理 (Loop)",
      "意味": "同じ、または似たような処理を、指定した回数や条件を満たす間、何度も実行すること。",
      "サンプルコード": "for i in range(3):\n    print('こんにちは')"
    },
    {
      "用語名": "for ループ",
      "意味": "リストや文字列など、複数の要素を持つデータから要素を1つずつ順番に取り出し、すべての要素に対して処理を繰り返す構文。",
      "サンプルコード": "fruits = ['apple', 'banana', 'cherry']\nfor fruit in fruits:\n    print(fruit)"
    },
    {
      "用語名": "while ループ",
      "意味": "指定した条件式が `True` である間、処理を繰り返し続ける構文。繰り返す回数が決まっていない場合に便利。",
      "サンプルコード": "count = 0\nwhile count < 3:\n    print(f'回数: {count}')\n    count += 1"
    },
    {
      "用語名": "イテラブル (Iterable)",
      "意味": "`for`ループで、中の要素を一つずつ順番に取り出すことができるオブジェクトのこと。リスト、タプル、文字列、range()オブジェクトなど。",
      "サンプルコード": "# 'hello'という文字列はイテラブル\nfor char in 'hello':\n    print(char)"
    },
    {
      "用語名": "ループ変数",
      "意味": "`for`ループで、イテラブルから取り出した要素が一時的に保存される変数のこと。",
      "サンプルコード": "for fruit in ['apple', 'banana']:\n    # この 'fruit' がループ変数"
    },
    {
      "用語名": "無限ループ (Infinite Loop)",
      "意味": "`while`ループの条件式が常に`True`になり、処理が永遠に終わらなくなってしまうこと。意図的に作る場合もあるが、多くはバグの原因になる。",
      "サンプルコード": "# 注意: このコードを実行すると止まらなくなる\n# while True:\n#     print('無限ループ中...')"
    },
    {
      "用語名": "カウンタ変数",
      "意味": "ループが何回実行されたかを数えるために使われる変数。`i` や `count` という名前がよく使われる。",
      "サンプルコード": "count = 1\nwhile count <= 5:\n    print(f'{count}回目のループ')\n    count += 1 # カウンタを1増やす"
    },
    {
      "用語名": "range() 関数",
      "意味": "連続した整数を生成する関数。`for`ループと組み合わせて、決まった回数だけ処理を繰り返したいときによく使われる。",
      "サンプルコード": "# 0, 1, 2, 3, 4 を順番に生成\nfor i in range(5):\n    print(i)"
    },
    {
      "用語名": "イテレーション (Iteration)",
      "意味": "ループ処理の1回1回の繰り返しのこと。「5回のイテレーション」は「5回ループが回ること」を意味する。",
      "サンプルコード": "# forループはリストの要素数だけイテレーションを繰り返す"
    }
,
    {
      "用語名": "break 文",
      "意味": "`for`や`while`のループの処理を、途中で強制的に中断してループから抜け出すための命令。",
      "サンプルコード": "for i in range(10):\n    if i == 3:\n        break # iが3になったらループを抜ける\n    print(i)\n# 0, 1, 2 と表示される"
    },
    {
      "用語名": "continue 文",
      "意味": "ループの現在の回の処理を途中で中断し、次の回の処理にスキップするための命令。ループ自体は中断されない。",
      "サンプルコード": "for i in range(5):\n    if i == 2:\n        continue # iが2の時はprintをスキップ\n    print(i)\n# 0, 1, 3, 4 と表示される"
    },
    {
      "用語名": "pass 文",
      "意味": "「何もしない」ということを表す命令。構文上何かを書く必要があるが、まだ処理内容が決まっていない場所などに、仮のプレースホルダーとして使う。",
      "サンプルコード": "if True:\n    pass # とりあえず何も処理しない"
    },
    {
      "用語名": "ループの else 句",
      "意味": "ループが `break` で中断されずに、最後まで正常に完了した場合にだけ実行される処理を書く部分。",
      "サンプルコード": "for i in range(3):\n    print(i)\nelse:\n    print('ループが正常に完了しました')\n# 0, 1, 2, '...'と表示される"
    },
    {
      "用語名": "フラグ (Flag)",
      "意味": "プログラムの特定の状態（例: 条件を満たす要素が見つかったか）を `True`/`False` などで記録しておくための変数。ループの制御によく使われる。",
      "サンプルコード": "numbers = [1, 5, 8, 9]\nfound_even = False # 偶数を見つけたかどうかのフラグ\nfor num in numbers:\n    if num % 2 == 0:\n        found_even = True\n        break\nif found_even:\n    print('偶数が見つかりました')"
    },
    {
      "用語名": "enumerate() 関数",
      "意味": "`for`ループで、リストなどの要素とそのインデックス（番号）を同時に取得したいときに使う便利な関数。",
      "サンプルコード": "fruits = ['apple', 'banana']\nfor index, fruit in enumerate(fruits):\n    print(f'{index}: {fruit}')"
    },
    {
      "用語名": "zip() 関数",
      "意味": "複数のリストなどから、要素を同時に1つずつ取り出してペア（タプル）にしてくれる関数。長さが違う場合は短い方に合わされる。",
      "サンプルコード": "names = ['Taro', 'Jiro']\nages = [20, 25]\nfor name, age in zip(names, ages):\n    print(f'{name}は{age}歳')"
    },
    {
      "用語名": "リスト内包表記",
      "意味": "`for`ループと`if`文を組み合わせて、新しいリストを1行で簡潔に作るための書き方。",
      "サンプルコード": "# 0から9までの偶数だけを2乗したリスト\nsquares = [x**2 for x in range(10) if x % 2 == 0]\nprint(squares) # [0, 4, 16, 36, 64]"
    },
    {
      "用語名": "in 演算子",
      "意味": "ある要素がリストや文字列などのイテラブルに含まれているかどうかを調べる。`if`文の条件でよく使われる。",
      "サンプルコード": "fruits = ['apple', 'banana']\nif 'apple' in fruits:\n    print('りんごがあります')"
    },
    {
      "用語名": "not in 演算子",
      "意味": "`in`の逆。含まれていないことを確認する。",
      "サンプルコード": "if 'orange' not in fruits:\n    print('オレンジはありません')"
    },
    {
      "用語名": "is 演算子",
      "意味": "2つの変数が、メモリ上で全く同じオブジェクト（モノ）を指しているかどうかを調べる。`None`の判定などで使われる。",
      "サンプルコード": "x = None\nif x is None:\n    print('xは何も指していません')"
    },
    {
      "用語名": "None",
      "意味": "「何もない」ことを表す特別な値。変数がまだ値を持っていない状態を示すのによく使われる。",
      "サンプルコード": "result = None"
    },
    {
      "用語名": "ウォルラス演算子 `:=`",
      "意味": "Python 3.8で追加。式の中で変数に値を代入できる。`while`文などでコードを短く書けることがある。",
      "サンプルコード": "# while True: のループを短く書ける例\n# while (line := input('何か入力: ')) != 'quit':\n#     print(f'入力されたのは: {line}')"
    },
    {
      "用語名": "match-case 文",
      "意味": "Python 3.10で追加。ある変数の値が、様々なパターン(case)のどれに一致(match)するかによって処理を分岐させる構文。",
      "サンプルコード": "status = 404\nmatch status:\n    case 200:\n        print('OK')\n    case 404:\n        print('Not Found')\n    case _:\n        print('Other error')"
    },
    {
      "用語名": "パターンマッチング",
      "意味": "`match-case`文で行われる、値の構造やパターンを照合する仕組みのこと。",
      "サンプルコード": "# 上記のmatch-case文がパターンマッチングの一例"
    }
,
    {
      "用語名": "SyntaxError",
      "意味": "文法エラー。Pythonのルールに従っていない書き方をしたときに発生する。`if`文の最後のコロン `:` を忘れるなど。",
      "サンプルコード": "# if True  # コロンがないのでSyntaxError\n#     print('hello')"
    },
    {
      "用語名": "IndentationError",
      "意味": "インデント（字下げ）が正しくないときに発生するエラー。Pythonでは特に起こりやすい。",
      "サンプルコード": "# if True:\n# print('インデントがずれているので IndentationError')"
    },
    {
      "用語名": "TypeError",
      "意味": "データ型が不適切な操作をしようとした時に発生するエラー。例えば、文字列と数値を `+` で足そうとするなど。",
      "サンプルコード": "# 'Age: ' + 20 # TypeError"
    },
    {
      "用語名": "NameError",
      "意味": "定義されていない変数名や関数名を使おうとしたときに発生するエラー。",
      "サンプルコード": "# print(my_variable) # 定義されていないのでNameError"
    },
    {
      "用語名": "IndexError",
      "意味": "リストなどで、範囲外のインデックス番号を指定したときに発生するエラー。",
      "サンプルコード": "my_list = [10, 20]\n# print(my_list[2]) # 2番目の要素はないのでIndexError"
    },
    {
      "用語名": "デバッグ (Debug)",
      "意味": "プログラムの間違い（バグ）を見つけて修正する作業のこと。",
      "サンプルコード": "# print()を使って変数の値を確認するのはデバッグの第一歩"
    },
    {
      "用語名": "print デバッグ",
      "意味": "プログラムの途中の変数の値を `print()` で表示させて、意図した通りに動いているかを確認する最も基本的なデバッグ手法。",
      "サンプルコード": "x = 10\ny = 20\nprint(f'計算前のx: {x}, y: {y}')\nz = x + y\nprint(f'計算後のz: {z}')"
    },
    {
      "用語名": "ブレークポイント (Breakpoint)",
      "意味": "デバッガ（デバッグ支援ツール）を使ってプログラムを一時停止させる目印のこと。その時点での変数の状態などを詳しく調べられる。",
      "サンプルコード": "# エディタの機能で、行の横をクリックして設定することが多い"
    },
    {
      "用語名": "ステップ実行 (Step Execution)",
      "意味": "デバッガでプログラムを一時停止させた後、1行ずつ実行していくこと。処理の流れを詳細に追跡できる。",
      "サンプルコード": "# デバッガの「ステップオーバー」「ステップイン」などの機能を使う"
    },

    {
      "用語名": "関数 (Function)",
      "意味": "特定の処理をひとまとめにしたもので、名前を付けて何度も呼び出して使えるようにしたもの。プログラムの部品のような存在。",
      "サンプルコード": "def say_hello():\n    print('こんにちは')\n\nsay_hello() # 関数を呼び出す"
    },
    {
      "用語名": "def キーワード",
      "意味": "関数を「定義 (define)」する（作る）ときに、先頭に付けるおまじないの言葉。",
      "サンプルコード": "def my_function(): # defで関数定義を開始\n    pass"
    },
    {
      "用語名": "関数を定義する (Define a function)",
      "意味": "新しい関数を作ること。どんな処理をするのか、その内容を記述すること。",
      "サンプルコード": "# addという名前の関数を定義する\ndef add(a, b):\n    return a + b"
    },
    {
      "用語名": "関数を呼び出す (Call a function)",
      "意味": "定義した関数に、実際に処理を実行してもらうようにお願いすること。`関数名()` のように書く。",
      "サンプルコード": "def say_goodbye():\n    print('さようなら')\n\nsay_goodbye() # ここで関数を呼び出している"
    },
    {
      "用語名": "引数 (Argument / Parameter)",
      "意味": "関数に処理を頼むときに渡す「情報」や「データ」のこと。関数側で受け取る変数を「仮引数」、呼び出すときに渡す値を「実引数」と区別することもある。",
      "サンプルコード": "def greet(name): # nameが引数\n    print(f'こんにちは, {name}さん')\n\ngreet('佐藤') # '佐藤'が引数として渡される"
    },
    {
      "用語名": "戻り値 (Return Value)",
      "意味": "関数が処理を終えた後に、呼び出し元に返す「結果」のこと。`return` キーワードを使って返す。",
      "サンプルコード": "def add(a, b):\n    result = a + b\n    return result # resultが戻り値\n\nanswer = add(5, 3)\nprint(answer) # 8"
    },
    {
      "用語名": "return キーワード",
      "意味": "関数の処理を終了し、指定した値を戻り値として返すための命令。`return`が実行されると、その時点で関数の処理は終わる。",
      "サンプルコード": "def check_age(age):\n    if age < 0:\n        return '不正な値です'\n    return 'OKです'"
    },
    {
      "用語名": "docstring (ドキュメンテーション文字列)",
      "意味": "関数の定義の直後に `'''` や `\"\"\"` で囲んで書く、その関数の説明文。後から他の人が見ても何をする関数か分かりやすくなる。",
      "サンプルコード": "def add(a, b):\n    '''\n    2つの数値を足し算して返す関数です。\n    '''\n    return a + b"
    },
    {
      "用語名": "副作用 (Side Effect)",
      "意味": "関数が戻り値を返すだけでなく、関数の外側の変数（グローバル変数など）を変更したり、画面に何かを表示したりすること。",
      "サンプルコード": "name = 'Taro'\ndef change_name():\n    # グローバル変数を変更する副作用\n    global name\n    name = 'Jiro'"
    },
    {
      "用語名": "組み込み関数 (Built-in Function)",
      "意味": "Pythonに最初から用意されていて、いつでも自由に呼び出せる関数のこと。`print()` や `len()` など。",
      "サンプルコード": "print('Hello') # 組み込み関数\nlength = len('Python') # 組み込み関数"
    }
,
    {
      "用語名": "位置引数 (Positional Argument)",
      "意味": "関数を呼び出すときに、定義された仮引数の順番通りに渡す引数のこと。",
      "サンプルコード": "def profile(name, age):\n    print(f'名前:{name}, 年齢:{age}')\n\nprofile('Taro', 20) # 'Taro'がname, 20がageに対応"
    },
    {
      "用語名": "キーワード引数 (Keyword Argument)",
      "意味": "`仮引数名=値` のように、どの引数にどの値を渡すかを名前で指定する方法。順番を気にしなくてよくなる。",
      "サンプルコード": "def profile(name, age):\n    print(f'名前:{name}, 年齢:{age}')\n\nprofile(age=25, name='Jiro') # 順番が違ってもOK"
    },
    {
      "用語名": "デフォルト引数 (Default Argument)",
      "意味": "関数を定義するときに、引数に初期値を設定しておくこと。呼び出すときにその引数が省略されると、初期値が使われる。",
      "サンプルコード": "def greet(name, message='こんにちは'):\n    print(f'{name}さん, {message}')\n\ngreet('Taro') # messageは省略されたので'こんにちは'が使われる"
    },
    {
      "用語名": "*args (可変長位置引数)",
      "意味": "関数の引数の数が決まっていないときに、任意の数の位置引数をタプルとしてまとめて受け取るための書き方。",
      "サンプルコード": "def sum_all(*args):\n    total = 0\n    for num in args:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3, 4)) # 10"
    },
    {
      "用語名": "**kwargs (可変長キーワード引数)",
      "意味": "任意の数のキーワード引数を、辞書としてまとめて受け取るための書き方。",
      "サンプルコード": "def show_profile(**kwargs):\n    for key, value in kwargs.items():\n        print(f'{key}: {value}')\n\nshow_profile(name='Sato', age=30, city='Tokyo')"
    },
    {
      "用語名": "引数のアンパッキング",
      "意味": "リストやタプルの前に `*` を付けて関数に渡すことで、その要素をそれぞれ個別の位置引数として展開（アンパック）すること。",
      "サンプルコード": "def add(a, b, c):\n    return a + b + c\n\nnumbers = [1, 2, 3]\nprint(add(*numbers)) # add(1, 2, 3) と同じ意味"
    },
    {
      "用語名": "辞書のアンパッキング",
      "意味": "辞書の前に `**` を付けて関数に渡すことで、そのキーと値をキーワード引数として展開すること。",
      "サンプルコード": "def profile(name, age):\n    print(f'名前:{name}, 年齢:{age}')\n\nuser_data = {'name': 'Suzuki', 'age': 40}\nprofile(**user_data)"
    },
    {
      "用語名": "キーワード専用引数",
      "意味": "引数の前に `*` を置くことで、それ以降の引数をキーワード引数でしか渡せないように強制する書き方。",
      "サンプルコード": "def total_price(price, *, tax_rate):\n    return price * (1 + tax_rate)\n\n# total_price(1000, 0.1) # エラーになる\nprint(total_price(1000, tax_rate=0.1)) # OK"
    }
,
    {
      "用語名": "第一級オブジェクト (First-Class Citizen)",
      "意味": "Pythonでは、関数が変数や数値と同じように扱えるということ。変数に代入したり、他の関数の引数にしたり、戻り値にしたりできる。",
      "サンプルコード": "def hello():\n    print('Hello!')\n\nai_satsu = hello # 変数に関数を代入\nai_satsu()"
    },
    {
      "用語名": "高階関数 (Higher-Order Function)",
      "意味": "「関数を引数として受け取る」または「関数を戻り値として返す」ことができる関数のこと。",
      "サンプルコード": "def apply_twice(func, arg):\n    return func(func(arg))\n\ndef add_five(x):\n    return x + 5\n\nprint(apply_twice(add_five, 10)) # 20"
    },
    {
      "用語名": "クロージャ (Closure)",
      "意味": "関数の中に関数があり、内側の関数が外側の関数の変数（状態）を記憶しているもの。外側の関数が終わっても、記憶した変数を使い続けられる。",
      "サンプルコード": "def outer(text):\n    def inner():\n        print(text) # 外側の変数'text'を記憶\n    return inner\n\nmy_func = outer('こんにちは')\nmy_func() # 'こんにちは'と表示"
    },
    {
      "用語名": "無名関数 (Anonymous Function)",
      "意味": "`def` を使って名前を付けずに、その場限りで使われる単純な関数のこと。Pythonでは `lambda` を使って作る。",
      "サンプルコード": "# lambda 引数: 式\nadd = lambda a, b: a + b\nprint(add(3, 5)) # 8"
    },
    {
      "用語名": "lambda (ラムダ式)",
      "意味": "一行で書ける簡単な無名関数を作成するためのキーワード。",
      "サンプルコード": "numbers = [1, 2, 3, 4]\neven_numbers = list(filter(lambda x: x % 2 == 0, numbers))\nprint(even_numbers) # [2, 4]"
    },
    {
      "用語名": "再帰関数 (Recursive Function)",
      "意味": "関数の中で、自分自身の関数を呼び出すことで処理を繰り返す関数。ループの代わりに使うことがある。",
      "サンプルコード": "def factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\nprint(factorial(4)) # 24 (4*3*2*1)"
    },
    {
      "用語名": "デコレータ (Decorator)",
      "意味": "既存の関数に、新しい機能を追加（デコレーション＝飾り付け）するための仕組み。`@` を使って記述する。",
      "サンプルコード": "def my_decorator(func):\n    def wrapper():\n        print('---処理開始---')\n        func()\n        print('---処理終了---')\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print('こんにちは')"
    }
,
    {
      "用語名": "ジェネレータ関数 (Generator Function)",
      "意味": "`yield` キーワードを使った関数。一度にすべての結果を返すのではなく、呼び出されるたびに順番に値を生成（yield）する。",
      "サンプルコード": "def count_up_to(max_num):\n    n = 1\n    while n <= max_num:\n        yield n\n        n += 1\n\nfor num in count_up_to(3):\n    print(num)"
    },
    {
      "用語名": "yield キーワード",
      "意味": "ジェネレータ関数で使われる `return` のようなもの。値を返すだけでなく、関数の状態を一時停止し、次回呼び出されたときにそこから再開する。",
      "サンプルコード": "# 上のジェネレータ関数のサンプルコードを参照"
    },
    {
      "用語名": "map() 関数",
      "意味": "リストなどの各要素に、特定の関数を適用して、その結果を新しいイテレータとして返す高階関数。",
      "サンプルコード": "numbers = [1, 2, 3]\nsquared = map(lambda x: x**2, numbers)\nprint(list(squared)) # [1, 4, 9]"
    },
    {
      "用語名": "filter() 関数",
      "意味": "リストなどの各要素を特定の関数で判定し、結果が `True` になる要素だけを集めた新しいイテレータを返す高階関数。",
      "サンプルコード": "numbers = [1, 2, 3, 4, 5]\nevens = filter(lambda x: x % 2 == 0, numbers)\nprint(list(evens)) # [2, 4]"
    },
    {
      "用語名": "コールバック関数 (Callback Function)",
      "意味": "他の関数に引数として渡され、ある処理が終わった後などに呼び出してもらう（コールバックしてもらう）ための関数。",
      "サンプルコード": "def on_complete():\n    print('処理が完了しました。')\n\ndef long_task(callback):\n    # 時間のかかる処理...\n    print('タスク実行中...')\n    callback()\n\nlong_task(on_complete)"
    },
    {
      "用語名": "純粋関数 (Pure Function)",
      "意味": "1. 同じ引数で呼び出すと必ず同じ戻り値を返す。 2. 副作用がない。という2つの条件を満たす関数のこと。テストがしやすく、予測可能な動作をする。",
      "サンプルコード": "def pure_add(a, b): # 純粋関数\n    return a + b\n\nglobal_x = 10\ndef impure_add(a): # 純粋ではない関数\n    return a + global_x"
    }
,
    { "用語名": "abs()", "意味": "数値の絶対値を返す。", "サンプルコード": "print(abs(-10)) # 10" },
    { "用語名": "all()", "意味": "イテラブルのすべての要素がTrue（またはTrueと判定される値）であればTrueを返す。", "サンプルコード": "print(all([True, 1, 'a'])) # True\nprint(all([True, 0, 'a'])) # False" },
    { "用語名": "any()", "意味": "イテラブルのいずれかの要素がTrueであればTrueを返す。", "サンプルコード": "print(any([False, 0, ''])) # False\nprint(any([False, 0, 'a'])) # True" },
    { "用語名": "chr()", "意味": "文字コード（Unicodeコードポイント）の数値を文字に変換する。", "サンプルコード": "print(chr(65)) # 'A'" },
    { "用語名": "divmod()", "意味": "割り算の商と余りを同時にタプルで返す。", "サンプルコード": "print(divmod(10, 3)) # (3, 1)" },
    { "用語名": "enumerate()", "意味": "イテラブルの要素に、インデックス番号を付けながら取り出すことができる。", "サンプルコード": "for i, fruit in enumerate(['apple', 'banana']):\n    print(i, fruit)" },
    { "用語名": "input()", "意味": "ユーザー（使う人）にキーボードから文字列を入力してもらい、その値を受け取る。", "サンプルコード": "name = input('あなたの名前は？ ')\nprint(f'こんにちは, {name}さん')" },
    { "用語名": "int()", "意味": "文字列や数値を整数（integer）に変換する。", "サンプルコード": "num_str = '100'\nnum_int = int(num_str)\nprint(num_int + 50) # 150" },
    { "用語名": "isinstance()", "意味": "オブジェクトが、指定したクラス（型）のインスタンスであるかどうかを調べる。", "サンプルコード": "print(isinstance(10, int)) # True\nprint(isinstance('a', int)) # False" },
    { "用語名": "max()", "意味": "イテラブルの中の最大の要素、または複数の引数の中の最大値を返す。", "サンプルコード": "print(max(1, 5, 2)) # 5\nprint(max([1, 5, 2])) # 5" },
    { "用語名": "min()", "意味": "イテラブルの中の最小の要素、または複数の引数の中の最小値を返す。", "サンプルコード": "print(min(1, 5, 2)) # 1\nprint(min([1, 5, 2])) # 1" },
    { "用語名": "open()", "意味": "ファイルを読み書きするために開く。", "サンプルコード": "with open('test.txt', 'w') as f:\n    f.write('hello')" },
    { "用語名": "ord()", "意味": "文字を文字コードの数値に変換する。`chr()`の逆。", "サンプルコード": "print(ord('A')) # 65" },
    { "用語名": "pow()", "意味": "べき乗を計算する。`pow(x, y)` は `x ** y` と同じ。", "サンプルコード": "print(pow(2, 3)) # 8" },
    { "用語名": "range()", "意味": "連続した整数のシーケンスを生成する。forループでよく使われる。", "サンプルコード": "for i in range(5): # 0, 1, 2, 3, 4\n    print(i)" },
    { "用語名": "round()", "意味": "数値を四捨五入する（正確には偶数への丸め）。", "サンプルコード": "print(round(3.14)) # 3\nprint(round(2.5)) # 2\nprint(round(3.5)) # 4" },
    { "用語名": "sorted()", "意味": "イテラブルの要素を並べ替えた新しいリストを返す。", "サンプルコード": "numbers = [3, 1, 4]\nnew_list = sorted(numbers)\nprint(new_list) # [1, 3, 4]" },
    { "用語名": "str()", "意味": "オブジェクトを文字列に変換する。", "サンプルコード": "age = 20\nprint('年齢は' + str(age) + '歳です')" },
    { "用語名": "sum()", "意味": "イテラブル（数値）のすべての要素の合計を返す。", "サンプルコード": "print(sum([1, 2, 3, 4, 5])) # 15" },
    { "用語名": "zip()", "意味": "複数のイテラブルから要素を同時に取り出し、タプルにまとめてくれる。", "サンプルコード": "names = ['Taro', 'Jiro']\nages = [20, 25]\nfor name, age in zip(names, ages):\n    print(name, age)" },


    {
      "用語名": "変数 (Variable)",
      "意味": "データ（値）を入れておくための名前付きの「箱」。中身は後から入れ替えることができる。",
      "サンプルコード": "name = 'Taro' # 'name'という名前の変数に'Taro'という文字列を入れる\n_age = 20"
    },
    {
      "用語名": "代入 (Assignment)",
      "意味": "変数に値を入れること。イコール記号 `=` を使う。",
      "サンプルコード": "score = 100 # scoreという変数に100を代入する"
    },
    {
      "用語名": "型 (Type)",
      "意味": "データの種類のこと。例えば、数値、文字列、リストなど、Pythonが値をどう扱うかを決める分類。",
      "サンプルコード": "x = 10       # int型 (整数)\ny = 'Hello'  # str型 (文字列)\nz = [1, 2]   # list型 (リスト)"
    },
    {
      "用語名": "動的型付け (Dynamic Typing)",
      "意味": "変数の型を最初に決めなくても、代入された値によってPythonが自動的に型を判断してくれる仕組み。",
      "サンプルコード": "data = 10\nprint(type(data)) # <class 'int'>\ndata = 'Hello'\nprint(type(data)) # <class 'str'>"
    },
    {
      "用語名": "type() 関数",
      "意味": "変数や値の型が何かを調べるための組み込み関数。",
      "サンプルコード": "print(type(123))    # <class 'int'>\nprint(type('abc'))  # <class 'str'>"
    },
    {
      "用語名": "整数型 (int)",
      "意味": "小数点のない数値の型。例: -1, 0, 100",
      "サンプルコード": "user_count = 50"
    },
    {
      "用語名": "浮動小数点数型 (float)",
      "意味": "小数点のある数値の型。例: -0.5, 3.14",
      "サンプルコード": "pi = 3.14159"
    },
    {
      "用語名": "ブール型 (bool)",
      "意味": "「正しい(True)」か「間違っている(False)」の2つの値だけを持つ型。if文などの条件分岐で使われる。",
      "サンプルコード": "is_active = True\nis_game_over = False"
    },
    {
      "用語名": "None",
      "意味": "「何もない」ことを表す特別な値。データがまだ存在しない状態を示すときなどに使われる。",
      "サンプルコード": "result = None"
    },
    {
      "用語名": "型変換 / キャスト (Type Casting)",
      "意味": "ある型の値を別の型に変換すること。`int()`, `str()`, `float()` などの関数を使う。",
      "サンプルコード": "str_num = '100'\nint_num = int(str_num)\nprint(int_num + 50) # 150"
    },
    {
      "用語名": "リテラル (Literal)",
      "意味": "プログラムのコードに直接書き込まれた値のこと。`100` や `'Hello'` など。",
      "サンプルコード": "x = 100 # 100が整数リテラル\ny = 'Hello' # 'Hello'が文字列リテラル"
    },
    {
      "用語名": "キーワード (Keyword)",
      "意味": "Pythonが特別な意味を持つと決めている単語（予約語）。`if`, `for`, `class` など。変数名には使えない。",
      "サンプルコード": "# for, in, if はキーワード\nfor i in range(3):\n    if i == 2:\n        print('Found!')"
    }
,
    {
      "用語名": "文字列 (String / str)",
      "意味": "文字の並びを表すデータ型。シングルクォート `' '` またはダブルクォート `\" \"` で囲んで作る。",
      "サンプルコード": "message1 = 'こんにちは'\nmessage2 = \"Hello, World!\""
    },
    {
      "用語名": "トリプルクォート",
      "意味": "シングルまたはダブルクォート3つで囲むと、複数行にわたる文字列を作ることができる。",
      "サンプルコード": "long_text = '''\nこれは\n複数行の\n文字列です。\n'''"
    },
    {
      "用語名": "エスケープシーケンス",
      "意味": "文字列の中で特別な意味を持つ文字の組み合わせ。`\\n` は改行、`\\t` はタブを表す。",
      "サンプルコード": "print('一行目\\n二行目')"
    },
    {
      "用語名": "raw文字列 (Raw String)",
      "意味": "文字列の先頭に `r` を付けると、エスケープシーケンスを無効化し、バックスラッシュ `\\` をそのまま文字として扱える。",
      "サンプルコード": "path = r'C:\\Users\\Documents'\nprint(path) # C:\\Users\\Documents"
    },
    {
      "用語名": "f-string (フォーマット済み文字列リテラル)",
      "意味": "文字列の先頭に `f` を付け、`{}` の中に変数名を書くことで、簡単に文字列の中に変数の値を埋め込める。",
      "サンプルコード": "name = 'Taro'\nage = 20\nmessage = f'私の名前は{name}です。年齢は{age}歳です。'\nprint(message)"
    },
    {
      "用語名": "len() 関数",
      "意味": "文字列やリストなどの「長さ（要素の数）」を調べるための組み込み関数。",
      "サンプルコード": "text = 'python'\nprint(len(text)) # 6"
    },
    {
      "用語名": "インデックス参照",
      "意味": "文字列の特定の位置にある1文字を取得する操作。0から始まる番号（インデックス）を使う。",
      "サンプルコード": "text = 'python'\nprint(text[0]) # 'p'\nprint(text[2]) # 't'"
    },
    {
      "用語名": "upper() / lower() メソッド",
      "意味": "文字列をすべて大文字 (`upper`) または小文字 (`lower`) に変換した、新しい文字列を返す。",
      "サンプルコード": "text = 'Hello'\nprint(text.upper()) # 'HELLO'\nprint(text.lower()) # 'hello'"
    },
    {
      "用語名": "strip() メソッド",
      "意味": "文字列の両端にある空白（スペース、改行、タブ）を取り除いた、新しい文字列を返す。",
      "サンプルコード": "text = '  hello world  '\nprint(text.strip()) # 'hello world'"
    },
    {
      "用語名": "replace() メソッド",
      "意味": "文字列の一部を、別の文字列に置き換えた、新しい文字列を返す。",
      "サンプルコード": "text = 'I like apple.'\nprint(text.replace('apple', 'banana')) # 'I like banana.'"
    },
    {
      "用語名": "split() メソッド",
      "意味": "文字列を指定した区切り文字で分割し、リストとして返す。",
      "サンプルコード": "text = 'apple,banana,cherry'\nfruits = text.split(',')\nprint(fruits) # ['apple', 'banana', 'cherry']"
    },
    {
      "用語名": "join() メソッド",
      "意味": "文字列のリストを、指定した文字列で連結して1つの文字列にする。`split()` の逆の操作。",
      "サンプルコード": "fruits = ['apple', 'banana', 'cherry']\ntext = ', '.join(fruits)\nprint(text) # 'apple, banana, cherry'"
    }
,
    {
      "用語名": "スライス (Slice)",
      "意味": "文字列やリストなどのシーケンスから、一部分を範囲指定して切り出す操作。`[開始:終了]` の形で書く。",
      "サンプルコード": "text = 'abcdefg'\nprint(text[1:4]) # 'bcd' (1番目から4番目の直前まで)"
    },
    {
      "用語名": "負のインデックス (Negative Index)",
      "意味": "シーケンスの末尾から数えるインデックス。`-1` が最後の要素、`-2` が最後から2番目の要素を指す。",
      "サンプルコード": "text = 'python'\nprint(text[-1]) # 'n'"
    },
    {
      "用語名": "ステップ (Step)",
      "意味": "スライスで、何個おきに要素を取り出すかを指定する。`[開始:終了:ステップ]` の形で書く。",
      "サンプルコード": "numbers = '0123456789'\nprint(numbers[::2]) # '02468' (最初から最後まで2個おき)"
    },
    {
      "用語名": "演算子 (Operator)",
      "意味": "足し算の `+` や引き算の `-` のように、計算や比較などの操作を行うための記号。",
      "サンプルコード": "result = 10 + 5 # '+' が演算子"
    },
    {
      "用語名": "算術演算子 (Arithmetic Operator)",
      "意味": "四則演算など、数学的な計算を行う演算子。`+`, `-`, `*` (掛け算), `/` (割り算), `%` (余り) など。",
      "サンプルコード": "print(10 % 3) # 1 (10を3で割った余り)"
    },
    {
      "用語名": "比較演算子 (Comparison Operator)",
      "意味": "2つの値を比較し、結果を `True` か `False` で返す演算子。`<` (より小さい), `>` (より大きい), `==` (等しい), `!=` (等しくない) など。",
      "サンプルコード": "age = 20\nprint(age >= 18) # True"
    },
    {
      "用語名": "論理演算子 (Logical Operator)",
      "意味": "複数の条件を組み合わせるための演算子。`and` (かつ), `or` (または), `not` (ではない) がある。",
      "サンプルコード": "score = 80\nattendance = 95\nif score >= 70 and attendance >= 90:\n    print('合格')"
    },
    {
      "用語名": "代入演算子 (Assignment Operator)",
      "意味": "右辺の値を左辺の変数に代入する `=` や、計算と代入を同時に行う `+=`, `-=` などの複合代入演算子。",
      "サンプルコード": "count = 0\ncount += 1 # count = count + 1 と同じ意味\nprint(count) # 1"
    },
    {
      "用語名": "文字列の連結 (`+`)",
      "意味": "`+` 演算子を使って、複数の文字列をつなぎ合わせて1つの新しい文字列を作ること。",
      "サンプルコード": "str1 = 'Hello, '\nstr2 = 'World!'\nmessage = str1 + str2\nprint(message) # 'Hello, World!'"
    },
    {
      "用語名": "文字列の繰り返し (`*`)",
      "意味": "`*` 演算子を使って、文字列を指定した回数だけ繰り返した新しい文字列を作ること。",
      "サンプルコード": "line = '-*' * 10\nprint(line) # '-*-*-*-*-*-*-*-*-*-*'"
    },
    {
      "用語名": "メンバーシップ演算子 (`in`)",
      "意味": "ある要素が、文字列やリストなどのシーケンスの中に含まれているかどうかを調べる。結果は `True` か `False`。",
      "サンプルコード": "text = 'hello world'\nprint('world' in text) # True\nprint('bye' in text) # False"
    },
    {
      "用語名": "同一性演算子 (`is`)",
      "意味": "2つの変数が、メモリ上で「全く同じオブジェクト（モノ）」を指しているかを調べる。`==` が「値が等しいか」を調べるのに対し、`is` は「存在が同じか」を調べる。",
      "サンプルコード": "a = [1, 2]\nb = [1, 2]\nc = a\nprint(a == b) # True (値は等しい)\nprint(a is b) # False (別のモノ)\nprint(a is c) # True (同じモノ)"
    },


    {
      "用語名": "プログラミング言語 (Programming Language)",
      "意味": "コンピュータにやってほしいことを命令するために人間が使う、特別な「言葉」。Pythonはその一種。",
      "サンプルコード": "print('Hello, World!') # Pythonという言語で「これを表示して」と命令している"
    },
    {
      "用語名": "ソースコード (Source Code)",
      "意味": "プログラミング言語で書かれた、命令の集まり。人間が読んで理解できるテキストファイル。",
      "サンプルコード": "# 以下がソースコードの例\nname = 'Taro'\nprint(f'こんにちは, {name}さん')"
    },
    {
      "用語名": "実行 (Execute)",
      "意味": "ソースコードに書かれた命令を、コンピュータが実際に処理すること。「プログラムを動かす」こと。",
      "サンプルコード": "# このコードを「実行」すると、画面に'Hello!'と表示される\nprint('Hello!')"
    },
    {
      "用語名": "インタプリタ (Interpreter)",
      "意味": "ソースコードを1行ずつコンピュータがわかる言葉（機械語）に翻訳しながら実行してくれるプログラム。Pythonがこれにあたる。",
      "サンプルコード": "# Pythonインタプリタがこの行を読んで、すぐに実行してくれる"
    },
    {
      "用語名": "文 (Statement)",
      "意味": "プログラムにおける、1つの命令の単位。多くの場合、1行が1つの文になる。",
      "サンプルコード": "x = 10       # 1つ目の文 (代入文)\nprint(x)   # 2つ目の文 (関数呼び出し文)"
    },
    {
      "用語名": "コメント (Comment)",
      "意味": "プログラムの動作には影響しない、人間が読むためのメモ。`#` を付けると、その行のそれ以降はコメントになる。",
      "サンプルコード": "# この行はコメントなので、コンピュータは無視する\nx = 10 # 変数xに10を代入（これもコメント）"
    },
    {
      "用語名": "インデント (Indentation)",
      "意味": "行の先頭にある空白（字下げ）。Pythonでは、このインデントを使ってコードのまとまり（ブロック）を表現するとても重要なルール。",
      "サンプルコード": "if True:\n    print('ここはインデントされている') # if文のブロック\nprint('ここはインデントされていない')"
    },
    {
      "用語名": "構文 / シンタックス (Syntax)",
      "意味": "プログラミング言語の「文法」ルール。ルールを間違えるとエラーになる。",
      "サンプルコード": "print('OK') # 正しい構文\n# print 'NG'  # Python 3では間違った構文 (SyntaxError)"
    },
    {
      "用語名": "エラー (Error)",
      "意味": "プログラムが文法を間違えたり、実行中に問題が起きたりして、途中で止まってしまうこと。",
      "サンプルコード": "# print(10 / 0) # ゼロで割ることはできないのでエラー (ZeroDivisionError) になる"
    },
    {
      "用語名": "デバッグ (Debug)",
      "意味": "プログラムの中からエラー（バグ）の原因を見つけて、修正する作業のこと。",
      "サンプルコード": "# x = '5'\n# y = 10\n# print(x + y) # これだとエラーになるので…\n# print(int(x) + y) # このように修正するのがデバッグ"
    },
    {
      "用語名": "アルゴリズム (Algorithm)",
      "意味": "問題を解決するための「手順」や「計算方法」のこと。プログラミングは、このアルゴリズムをコードに落とし込む作業。",
      "サンプルコード": "# 合計を求めるアルゴリズムの例\nnumbers = [1, 2, 3]\ntotal = 0\nfor n in numbers:\n    total += n"
    },
    {
      "用語名": "モジュール / ライブラリ (Module / Library)",
      "意味": "便利な機能があらかじめまとめられた、部品のようなもの。`import` して自分のプログラムで使える。",
      "サンプルコード": "import random # randomという、くじ引きなど便利な機能のモジュールを読み込む\nprint(random.randint(1, 6)) # 1〜6のランダムな数を表示"
    }
,
    {
      "用語名": "コマンドプロンプト (cmd)",
      "意味": "Windowsに標準で入っている、キーボードで命令（コマンド）を打ち込んでコンピュータを操作する黒い画面。",
      "サンプルコード": "C:\\> # このような表示（プロンプト）が出ている画面"
    },
    {
      "用語名": "コマンド (Command)",
      "意味": "コマンドプロンプトで打ち込む命令のこと。",
      "サンプルコード": "dir # 現在いる場所のファイル一覧を表示するコマンド"
    },
    {
      "用語名": "ディレクトリ (Directory)",
      "意味": "コンピュータのファイルやフォルダを整理するための「フォルダ」のこと。",
      "サンプルコード": "C:\\Users\\Taro\\Documents # Documentsというディレクトリ"
    },
    {
      "用語名": "カレントディレクトリ (Current Directory)",
      "意味": "今、自分がコマンドプロンプトで作業している場所（ディレクトリ）のこと。",
      "サンプルコード": "# プロンプト `C:\\Users\\Taro>` の `Taro` がカレントディレクトリ"
    },
    {
      "用語名": "パス (Path)",
      "意味": "ファイルやディレクトリの「住所」のこと。`C:\\Users\\Taro\\test.py` のような形式で表される。",
      "サンプルコード": "C:\\python\\python.exe # Python本体の場所を示すパス"
    },
    {
      "用語名": "`cd` コマンド",
      "意味": "カレントディレクトリを移動するためのコマンド (Change Directory)。",
      "サンプルコード": "cd Documents # Documentsディレクトリに移動する"
    },
    {
      "用語名": "`dir` コマンド",
      "意味": "カレントディレクトリにあるファイルやディレクトリの一覧を表示するコマンド。",
      "サンプルコード": "dir"
    },
    {
      "用語名": "Pythonの実行 (python)",
      "意味": "コマンドプロンプトで `python ファイル名.py` と打ち込むと、そのPythonプログラムを実行できる。",
      "サンプルコード": "python hello.py"
    },
    {
      "用語名": "対話モード (Interactive Mode)",
      "意味": "コマンドプロンプトで `python` とだけ打ち込むと始まるモード。1行ずつコードを打ち込んで、すぐに結果を確認できる。",
      "サンプルコード": ">>> print(1 + 2)\n3\n>>> # この '>>>' が対話モードの印"
    },
    {
      "用語名": "pip (ピップ)",
      "意味": "Pythonの便利な部品（ライブラリ）をインターネットからダウンロードして、自分のPCにインストールするための公式ツール。",
      "サンプルコード": "pip install requests # requestsというライブラリをインストールするコマンド"
    },
    {
      "用語名": "パッケージ (Package)",
      "意味": "pipでインストールできる、ライブラリやツールのこと。",
      "サンプルコード": "# `requests` や `numpy`, `pandas` などが有名なパッケージ"
    },
    {
      "用語名": "`pip install`",
      "意味": "パッケージをインストールするためのpipコマンド。",
      "サンプルコード": "pip install numpy"
    },
    {
      "用語名": "`pip list`",
      "意味": "現在インストールされているパッケージの一覧を表示するpipコマンド。",
      "サンプルコード": "pip list"
    },
    {
      "用語名": "環境変数PATH",
      "意味": "Windowsがプログラムを探しに行く場所（ディレクトリ）を登録しておく設定。ここにPythonのパスを登録すると、`cd`で移動しなくてもどこからでも `python` コマンドが使えるようになる。",
      "サンプルコード": "# Pythonインストーラーの 'Add Python to PATH' にチェックを入れると自動で設定される"
    }
,
    {
      "用語名": "開発環境 (Development Environment)",
      "意味": "プログラミング（開発）をするために必要なソフトウェアやツールの集まり。",
      "サンプルコード": "# テキストエディタ + コマンドプロンプト もシンプルな開発環境の一つ"
    },
    {
      "用語名": "テキストエディタ (Text Editor)",
      "意味": "ソースコードを書くための、シンプルな文章作成ソフト。メモ帳も一種だが、プログラミング用のものは文字が色付けされたりして便利。",
      "サンプルコード": "# 代表的なエディタ: Visual Studio Code, Sublime Text, Atomなど"
    },
    {
      "用語名": "統合開発環境 (IDE)",
      "意味": "コードを書くエディタ、実行するボタン、デバッグツールなど、開発に必要な機能が全部セットになった高機能なソフトウェア。",
      "サンプルコード": "# 代表的なIDE: PyCharm, Visual Studio, Eclipseなど"
    },
    {
      "用語名": "Visual Studio Code (VS Code)",
      "意味": "Microsoftが作っている、無料で高機能なテキストエディタ。拡張機能を入れることで、Pythonをはじめ様々な言語に対応できる。世界中で人気。",
      "サンプルコード": "# VS CodeにPython拡張機能を入れると、IDEのように使える"
    },
    {
      "用語名": "PyCharm (パイチャーム)",
      "意味": "Python開発に特化した、非常に強力なIDE。コードの入力補完やエラーチェック機能が優れている。無料版(Community)と有料版(Professional)がある。",
      "サンプルコード": "# 初心者からプロまで幅広く使われている"
    },
    {
      "用語名": "Jupyter Notebook (ジュピターノートブック)",
      "意味": "プログラムのコード、実行結果、説明文などを一つのノート形式のファイルにまとめて記録できるツール。データ分析や機械学習の分野でよく使われる。",
      "サンプルコード": "# ブラウザ上でコードをブロックごとに実行・確認できるのが特徴"
    },
    {
      "用語名": "Google Colaboratory (Colab)",
      "意味": "Googleが提供する、ブラウザだけでPythonを実行できる無料サービス。自分のPCに環境を作らなくても、すぐにPythonを試せる。Jupyter Notebookがベース。",
      "サンプルコード": "# URLにアクセスするだけで始められるので、初心者には特におすすめ"
    },
    {
      "用語名": "Anaconda (アナコンダ)",
      "意味": "Python本体に加え、データ分析や科学技術計算でよく使われる多数のライブラリ（NumPy, pandasなど）やJupyter Notebookがセットになった便利なパッケージ。",
      "サンプルコード": "# これをインストールするだけで、データ分析の環境がほぼ整う"
    },
    {
      "用語名": "仮想環境 (Virtual Environment)",
      "意味": "プロジェクトごとに、独立したPythonの実行環境を作る仕組み。他のプロジェクトで使っているライブラリのバージョンと混ざらないように部屋を分けるイメージ。",
      "サンプルコード": "python -m venv myenv # myenvという名前の仮想環境を作るコマンド"
    },
    {
      "用語名": "venv",
      "意味": "Python 3.3から標準で付属している、仮想環境を作成・管理するためのモジュール。",
      "サンプルコード": "# 仮想環境の有効化(Windows)\nmyenv\\Scripts\\activate"
    },
    {
      "用語名": "拡張機能 (Extension / Add-on)",
      "意味": "VS CodeなどのエディタやIDEに、後から追加できる便利な機能の部品。Pythonのサポート、コードの自動整形、見た目の変更などがある。",
      "サンプルコード": "# VS Codeのマーケットプレイスからインストールできる"
    },
    {
      "用語名": "Linter (リンター)",
      "意味": "ソースコードを分析して、文法的な間違いや、書き方のスタイルがルールに沿っているかをチェックしてくれるツール。",
      "サンプルコード": "# flake8, pylintなどが有名なPythonのLinter"
    },
    {
      "用語名": "Formatter (フォーマッター)",
      "意味": "ソースコードを、決められたルール（インデントの幅、改行の位置など）に従って自動的にきれいに整形してくれるツール。",
      "サンプルコード": "# Black, autopep8などが有名なPythonのFormatter"
    },
    {
      "用語名": "バージョン管理システム (Version Control System)",
      "意味": "ファイルの変更履歴を記録・管理するためのシステム。いつ、誰が、どこを修正したかが分かり、昔の状態に戻すこともできる。",
      "サンプルコード": "# Git (ギット) が最も広く使われているバージョン管理システム"
    },
    {
      "用語名": "Git (ギット)",
      "意味": "ソースコードなどの変更履歴を管理するための、代表的なバージョン管理ツール。",
      "サンプルコード": "git clone https://... # リモートリポジトリをコピーするコマンド"
    },
    {
      "用語名": "GitHub (ギットハブ)",
      "意味": "Gitを使って管理しているソースコードを、インターネット上で保存・共有できるウェブサービス。世界中の開発者が利用している。",
      "サンプルコード": "# チーム開発や、自分の作品を公開する場として使われる"
    }
,
    {
      "用語名": "エラー (Error)",
      "意味": "プログラムの文法間違い（構文エラー）や、実行中に起こる問題（例外）のこと。",
      "サンプルコード": "# 1 / 0  <- ゼロ除算エラー\n# 'a' + 2  <- 型エラー"
    },
    {
      "用語名": "例外 (Exception)",
      "意味": "プログラムの実行中に発生するエラーのこと。文法は合っているが、処理の途中で問題が起きた状態。",
      "サンプルコード": "numbers = [1, 2]\n# print(numbers[5]) # 存在しないインデックスを指定するとIndexErrorという例外が発生する"
    },
    {
      "用語名": "例外処理 (Exception Handling)",
      "意味": "例外が発生したときに、プログラムが強制終了しないように、あらかじめ備えておく処理のこと。",
      "サンプルコード": "try:\n    # エラーが起きるかもしれない処理\nexcept:\n    # エラーが起きたときの処理"
    },
    {
      "用語名": "`try` ブロック",
      "意味": "例外が発生する可能性のあるコードを囲むためのブロック。「まず、この処理を試してみて(Try)」という意味。",
      "サンプルコード": "try:\n    score = 100 / 0 # この処理を試す"
    },
    {
      "用語名": "`except` ブロック",
      "意味": "`try`ブロックの中で例外が発生した場合に実行されるコードを囲むブロック。「エラーが出た場合は、代わりにこちらをやって」という意味。",
      "サンプルコード": "except ZeroDivisionError:\n    print('0で割ることはできません！')"
    },
    {
      "用語名": "例外オブジェクト",
      "意味": "例外が発生したときに、そのエラーに関する詳しい情報を持っているオブジェクト。`except Exception as e:` の `e` で受け取れる。",
      "サンプルコード": "try:\n    1 / 0\nexcept Exception as e:\n    print(f'エラーの種類: {type(e)}')\n    print(f'エラーメッセージ: {e}')"
    },
    {
      "用語名": "`else` ブロック (例外処理)",
      "意味": "`try`ブロックで例外が発生しなかった場合にのみ実行されるブロック。「エラーが起きなかったら、これをやって」という意味。",
      "サンプルコード": "try:\n    print('処理成功')\nexcept:\n    print('エラー発生')\nelse:\n    print('エラーはありませんでした。')"
    },
    {
      "用語名": "`finally` ブロック",
      "意味": "例外が発生してもしなくても、`try`ブロックを抜けるときに必ず実行されるブロック。「何があっても、最後にこれは必ずやって」という意味。後片付け処理などに使う。",
      "サンプルコード": "try:\n    # file = open('data.txt')\n    pass\nfinally:\n    print('最後に必ず実行されます')\n    # file.close()"
    },
    {
      "用語名": "`raise`",
      "意味": "プログラマーが意図的に例外を発生させるための命令。特定の条件でエラーとして処理を中断させたいときに使う。",
      "サンプルコード": "age = -5\nif age < 0:\n    raise ValueError('年齢にマイナスの値は設定できません')"
    },
    {
      "用語名": "トレースバック (Traceback)",
      "意味": "例外が発生したときに表示されるエラーメッセージ全体のこと。どこで、どのようなエラーが発生したかの履歴が書かれている。",
      "サンプルコード": "# エラー発生時にコンソールに表示される詳細なエラー情報がトレースバック"
    },
    {
      "用語名": "SyntaxError",
      "意味": "構文エラー。プログラムの文法が間違っているときに発生する。インデントミスやコロンのつけ忘れなど。",
      "サンプルコード": "# for i in range(5) # ←コロンがないのでSyntaxError\n#    print(i)"
    },
    {
      "用語名": "IndentationError",
      "意味": "インデント（字下げ）のルールが間違っているときに発生する構文エラーの一種。",
      "サンプルコード": "def my_func():\n# print('インデントが足りない') # IndentationError"
    },
    {
      "用語名": "NameError",
      "意味": "定義されていない（作られていない）変数や関数を使おうとしたときに発生する例外。",
      "サンプルコード": "# print(my_variable) # 定義していないのでNameError"
    },
    {
      "用語名": "TypeError",
      "意味": "データ型が不適切なために操作ができないときに発生する例外。例: 文字列と数値を足そうとする。",
      "サンプルコード": "# result = 'Hello' + 5 # TypeError"
    },
    {
      "用語名": "ValueError",
      "意味": "データ型は正しいが、その「値」が不適切なために処理できないときに発生する例外。",
      "サンプルコード": "# num = int('abc') # 'abc'という文字列は整数に変換できないのでValueError"
    },
    {
      "用語名": "IndexError",
      "意味": "リストやタプルで、範囲外のインデックス（番号）を指定して要素にアクセスしようとしたときに発生する例外。",
      "サンプルコード": "my_list = [10, 20]\n# print(my_list[2]) # 2番目のインデックスは存在しないのでIndexError"
    },
    {
      "用語名": "KeyError",
      "意味": "辞書で、存在しないキーを指定して値にアクセスしようとしたときに発生する例外。",
      "サンプルコード": "my_dict = {'name': 'Taro'}\n# print(my_dict['age']) # 'age'というキーは存在しないのでKeyError"
    },
    {
      "用語名": "ZeroDivisionError",
      "意味": "数値を0（ゼロ）で割り算しようとしたときに発生する例外。",
      "サンプルコード": "# result = 100 / 0 # ZeroDivisionError"
    },
    {
      "用語名": "FileNotFoundError",
      "意味": "存在しないファイルを開こうとしたときに発生する例外。",
      "サンプルコード": "# with open('non_existent_file.txt') as f:\n#     pass # FileNotFoundError"
    },
    {
      "用語名": "カスタム例外 (Custom Exception)",
      "意味": "プログラマーが自分で定義する、独自の例外クラス。特定のアプリケーションのエラーを分かりやすく表現できる。",
      "サンプルコード": "class MyOriginalError(Exception):\n    pass\n\n# raise MyOriginalError('これは独自のエラーです')"
    }
,
    {
      "用語名": "組み込み関数 (Built-in Function)",
      "意味": "Pythonをインストールしたときから、`import`なしで最初から使える便利な関数のこと。",
      "サンプルコード": "print('Hello') # print()は代表的な組み込み関数"
    },
    {
      "用語名": "print()",
      "意味": "カッコの中身を画面（コンソール）に表示する。",
      "サンプルコード": "print('こんにちは', 123)"
    },
    {
      "用語名": "input()",
      "意味": "キーボードからの文字入力を受け付け、その内容を文字列として返す。",
      "サンプルコード": "name = input('あなたの名前は？ ')\nprint(f'こんにちは、{name}さん')"
    },
    {
      "用語名": "len()",
      "意味": "文字列の文字数や、リストの要素数など、オブジェクトの「長さ」を返す。",
      "サンプルコード": "print(len('python')) # 6\nprint(len([1, 2, 3])) # 3"
    },
    {
      "用語名": "type()",
      "意味": "オブジェクトの「型」を調べる。",
      "サンプルコード": "print(type(100)) # <class 'int'>\nprint(type('hello')) # <class 'str'>"
    },
    {
      "用語名": "int() / float() / str()",
      "意味": "値をそれぞれ整数(int)、浮動小数点数(float)、文字列(str)に型変換する。",
      "サンプルコード": "num_str = '123'\nnum_int = int(num_str)\nprint(num_int + 100) # 223"
    },
    {
      "用語名": "list() / tuple() / set()",
      "意味": "値をそれぞれリスト、タプル、集合に変換する。文字列を1文字ずつに分解するときなどにも使う。",
      "サンプルコード": "print(list('abc')) # ['a', 'b', 'c']\nprint(set([1, 2, 1])) # {1, 2}"
    },
    {
      "用語名": "sum()",
      "意味": "リストなど、数値の集まりの合計値を計算する。",
      "サンプルコード": "scores = [80, 90, 70]\nprint(sum(scores)) # 240"
    },
    {
      "用語名": "max()",
      "意味": "数値の集まりの中から最大値を返す。",
      "サンプルコード": "numbers = [10, 50, 20]\nprint(max(numbers)) # 50"
    },
    {
      "用語名": "min()",
      "意味": "数値の集まりの中から最小値を返す。",
      "サンプルコード": "numbers = [10, 50, 20]\nprint(min(numbers)) # 10"
    },
    {
      "用語名": "abs()",
      "意味": "数値の絶対値（0からの距離）を返す。",
      "サンプルコード": "print(abs(-10)) # 10"
    },
    {
      "用語名": "round()",
      "意味": "浮動小数点数を四捨五入して、最も近い整数または指定した桁数に丸める。",
      "サンプルコード": "print(round(3.14159)) # 3\nprint(round(3.14159, 2)) # 3.14"
    },
    {
      "用語名": "range()",
      "意味": "連続した数値のシーケンスを生成する。forループと組み合わせてよく使う。",
      "サンプルコード": "for i in range(5): # 0, 1, 2, 3, 4\n    print(i)"
    },
    {
      "用語名": "sorted()",
      "意味": "リストなどのイテラブルを並べ替えた「新しいリスト」を返す。元のリストは変わらない。",
      "サンプルコード": "numbers = [3, 1, 4]\nnew_list = sorted(numbers)\nprint(new_list) # [1, 3, 4]"
    },
    {
      "用語名": "reversed()",
      "意味": "リストなどのシーケンスの要素を逆順に取り出すための「イテレータ」を返す。結果を使いたいときはlist()などで変換する。",
      "サンプルコード": "numbers = [1, 2, 3]\nrev_list = list(reversed(numbers))\nprint(rev_list) # [3, 2, 1]"
    },
    {
      "用語名": "enumerate()",
      "意味": "リストなどをforループで回すときに、インデックス番号と要素をペアで取り出すことができる。",
      "サンプルコード": "fruits = ['apple', 'banana']\nfor index, fruit in enumerate(fruits):\n    print(index, fruit) # 0 apple, 1 banana"
    },
    {
      "用語名": "zip()",
      "意味": "複数のリストなどから、同じ位置にある要素をペアにしたタプルを作り出す。",
      "サンプルコード": "names = ['Taro', 'Hana']\nages = [20, 18]\nfor name, age in zip(names, ages):\n    print(name, age) # Taro 20, Hana 18"
    },
    {
      "用語名": "bool()",
      "意味": "値をブール型(True/False)に変換する。`0`や空の文字列`''`、空のリスト`[]`などは`False`になり、それ以外はほとんど`True`になる。",
      "サンプルコード": "print(bool(10)) # True\nprint(bool(0)) # False\nprint(bool('')) # False"
    },
    {
      "用語名": "all()",
      "意味": "リストなどの要素が「すべて」Trueと評価される場合にTrueを返す。",
      "サンプルコード": "print(all([True, True, True])) # True\nprint(all([True, False, True])) # False"
    },
    {
      "用語名": "any()",
      "意味": "リストなどの要素の「いずれか1つでも」Trueと評価される場合にTrueを返す。",
      "サンプルコード": "print(any([False, False, True])) # True\nprint(any([False, False, False])) # False"
    },
    {
      "用語名": "isinstance()",
      "意味": "オブジェクトが、指定したクラス（型）のインスタンスであるかどうかを調べる。",
      "サンプルコード": "x = 100\nprint(isinstance(x, int)) # True\nprint(isinstance(x, str)) # False"
    },
    {
      "用語名": "help()",
      "意味": "対話モードで、関数やモジュールの使い方（ドキュメント）を表示する。",
      "サンプルコード": ">>> help(print)"
    },
    {
      "用語名": "dir()",
      "意味": "オブジェクトが持っている属性（アトリビュート）やメソッドの一覧を表示する。",
      "サンプルコード": "text = 'hello'\nprint(dir(text)) # .upper(), .lower()などが見つかる"
    },
    {
      "用語名": "id()",
      "意味": "オブジェクトがメモリ上のどこに保存されているかを示す、一意のID番号を返す。",
      "サンプルコード": "x = [1, 2]\ny = x\nprint(id(x) == id(y)) # True (同じものを指している)"
    },
    {
      "用語名": "open()",
      "意味": "ファイルを開いて、読み書きの準備をする。通常は`with`構文と一緒に使う。",
      "サンプルコード": "with open('myfile.txt', 'w') as f:\n    f.write('Hello')"
    },
    {
      "用語名": "map()",
      "意味": "リストなどの各要素に、同じ関数を適用して、その結果をまとめて得たいときに使う。",
      "サンプルコード": "numbers = ['1', '2', '3']\nint_numbers = list(map(int, numbers))\nprint(int_numbers) # [1, 2, 3]"
    },
    {
      "用語名": "filter()",
      "意味": "リストなどの各要素を、条件となる関数でチェックし、条件に合った（Trueになる）要素だけを取り出したいときに使う。",
      "サンプルコード": "def is_even(n):\n    return n % 2 == 0\n\nnumbers = [1, 2, 3, 4, 5]\neven_numbers = list(filter(is_even, numbers))\nprint(even_numbers) # [2, 4]"
    },
    {
      "用語名": "pow()",
      "意味": "べき乗を計算する。`pow(x, y)` は `x` の `y` 乗を返す。",
      "サンプルコード": "print(pow(2, 3)) # 8 (2の3乗)"
    },
    {
      "用語名": "chr()",
      "意味": "文字コード（Unicode）の番号から、対応する文字を返す。",
      "サンプルコード": "print(chr(65)) # 'A'"
    },
    {
      "用語名": "ord()",
      "意味": "文字から、対応する文字コード（Unicode）の番号を返す。`chr()`の逆。",
      "サンプルコード": "print(ord('A')) # 65"
    },


    {
      "用語名": "内包表記 (Comprehension)",
      "意味": "既存のリストなど（イテラブル）から、新しいリスト、辞書、集合を、forループを使わずに一行で簡潔に作り出すための書き方。",
      "サンプルコード": "# forループで書くと…\nsquares = []\nfor i in range(5):\n    squares.append(i**2)\n\n# 内包表記で書くと…\nsquares_comp = [i**2 for i in range(5)]"
    },
    {
      "用語名": "リスト内包表記 (List Comprehension)",
      "意味": "新しいリストを作り出すための内包表記。角括弧 `[]` を使う。",
      "サンプルコード": "even_numbers = [i for i in range(10) if i % 2 == 0]\nprint(even_numbers) # [0, 2, 4, 6, 8]"
    },
    {
      "用語名": "辞書内包表記 (Dictionary Comprehension)",
      "意味": "新しい辞書を作り出すための内包表記。波括弧 `{}` とキー・値のペア `key: value` を使う。",
      "サンプルコード": "squares_dict = {i: i**2 for i in range(5)}\nprint(squares_dict) # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}"
    },
    {
      "用語名": "集合内包表記 (Set Comprehension)",
      "意味": "新しい集合を作り出すための内包表記。波括弧 `{}` を使う。重複した要素は自動的に取り除かれる。",
      "サンプルコード": "unique_chars = {c for c in 'hello world'}\nprint(unique_chars) # {'w', 'e', 'd', 'l', ' ', 'o', 'r', 'h'}"
    },
    {
      "用語名": "条件分岐 (`if`)",
      "意味": "内包表記の中で、条件に合う要素だけを絞り込むために `if` を使うことができる。",
      "サンプルコード": "# 3の倍数だけを取り出す\nmultiples_of_3 = [i for i in range(20) if i % 3 == 0]"
    },
    {
      "用語名": "ネストしたforループ",
      "意味": "内包表記の中で `for` を複数使うことで、入れ子（ネスト）になったループを表現できる。",
      "サンプルコード": "pairs = [(x, y) for x in [1, 2] for y in ['a', 'b']]\nprint(pairs) # [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]"
    },
    {
      "用語名": "三項演算子 (`if-else`)",
      "意味": "内包表記の中で、条件によって要素の値を振り分けたいときに使う。`A if condition else B` の形で書く。",
      "サンプルコード": "results = ['偶数' if i % 2 == 0 else '奇数' for i in range(5)]\nprint(results) # ['偶数', '奇数', '偶数', '奇数', '偶数']"
    },
    {
      "用語名": "`map()` / `filter()` との比較",
      "意味": "内包表記は、`map()` や `filter()` といった関数型プログラミングの道具と同じような処理を、より直感的に書けることが多い。",
      "サンプルコード": "# filter()の場合: list(filter(lambda i: i % 2 == 0, range(10)))\n# 内包表記の場合: [i for i in range(10) if i % 2 == 0]"
    },
    {
      "用語名": "可読性 (Readability)",
      "意味": "コードの読みやすさのこと。内包表記は便利だが、複雑になりすぎると逆に可読性が下がるため、通常のforループと使い分けるのが良い。",
      "サンプルコード": "# 複雑な内包表記は避けるのがベター\n# [[calc(j) for j in i] for i in data if cond(i)]"
    },
    {
      "用語名": "パフォーマンス",
      "意味": "プログラムの処理速度。一般的に、内包表記はPython内部で最適化されているため、同じ処理を `for` ループで書くよりも高速に動作することが多い。",
      "サンプルコード": "# 内包表記は多くの場合、効率が良い"
    }
,
    {
      "用語名": "ジェネレータ (Generator)",
      "意味": "イテレータ（forループで回せるもの）の一種で、要素を一度にすべて作るのではなく、必要になるたびに一つずつ生成する仕組み。メモリを節約できる。",
      "サンプルコード": "# ジェネレータを作る方法にはジェネレータ式とジェネレータ関数がある"
    },
    {
      "用語名": "ジェネレータ式 (Generator Expression)",
      "意味": "内包表記と非常によく似た構文でジェネレータを作る書き方。角括弧 `[]` の代わりに丸括弧 `()` を使う。",
      "サンプルコード": "gen_exp = (i**2 for i in range(5))\nprint(gen_exp) # <generator object <genexpr> at ...>"
    },
    {
      "用語名": "遅延評価 (Lazy Evaluation)",
      "意味": "ジェネレータの最大の特徴。式が書かれた時点では計算は実行されず、実際に値が必要になるまで処理を遅らせること。",
      "サンプルコード": "large_gen = (i for i in range(10**8)) # この時点ではメモリをほとんど消費しない"
    },
    {
      "用語名": "メモリ効率",
      "意味": "ジェネレータは一度に1つの要素しかメモリ上に保持しないため、巨大なデータや無限のシーケンスを扱う際に非常にメモリ効率が良い。",
      "サンプルコード": "# もしリスト内包表記だとメモリを使い果たしてしまうような処理\n# large_list = [i for i in range(10**8)] # メモリ不足になる可能性"
    },
    {
      "用語名": "`next()` 関数",
      "意味": "ジェネレータから次の要素を1つ取り出すための組み込み関数。",
      "サンプルコード": "gen = (i for i in 'abc')\nprint(next(gen)) # 'a'\nprint(next(gen)) # 'b'"
    },
    {
      "用語名": "StopIteration",
      "意味": "ジェネレータがすべての要素を生成し終えた後で、さらに `next()` を呼び出すと発生する例外。",
      "サンプルコード": "gen = (i for i in [1])\nnext(gen)\n# next(gen) # ここでStopIterationが発生"
    },
    {
      "用語名": "forループでの利用",
      "意味": "ジェネレータはイテラブルなので、forループで使うのが最も一般的。ループが自動的に `next()` を呼び出し、StopIterationでループを終了してくれる。",
      "サンプルコード": "total = 0\nfor num in (i for i in range(101)):\n    total += num\nprint(total) # 5050"
    },
    {
      "用語名": "ジェネレータ関数",
      "意味": "関数の中で `yield` キーワードを使うことで作られるジェネレータ。より複雑なロジックで値を生成できる。",
      "サンプルコード": "def count_up(limit):\n    n = 0\n    while n < limit:\n        yield n\n        n += 1"
    },
    {
      "用語名": "`yield` キーワード",
      "意味": "ジェネレータ関数の中で値を返すために使う。`return`と違い、関数の状態を一時停止して保持し、次回呼び出されたときにそこから再開する。",
      "サンプルコード": "def my_gen():\n    yield '一つ目'\n    yield '二つ目'"
    },
    {
      "用語名": "タプル内包表記？",
      "意味": "Pythonには「タプル内包表記」という専用の構文はない。`()` を使うと、それはタプルではなくジェネレータ式になる。",
      "サンプルコード": "# これはジェネレータ式\ngen = (i for i in range(3))\n# タプルにしたい場合は tuple() で変換する\ntpl = tuple(i for i in range(3))"
    }
,
    {
      "用語名": "ラムダ式 (Lambda Expression)",
      "意味": "`lambda` キーワードを使って作る、名前のない小さな使い捨て関数のこと。「無名関数」とも呼ばれる。",
      "サンプルコード": "add = lambda x, y: x + y\nprint(add(3, 5)) # 8"
    },
    {
      "用語名": "無名関数 (Anonymous Function)",
      "意味": "`def` を使って名前を付ける必要がない関数のこと。ラムダ式がこれにあたる。",
      "サンプルコード": "# `def add(x, y): return x + y` と書く代わり"
    },
    {
      "用語名": "構文 (`lambda arguments: expression`)",
      "意味": "コロン `:` の左側に引数を、右側にその引数を使った単一の式（返す値）を書く。",
      "サンプルコード": "square = lambda x: x**2"
    },
    {
      "用語名": "`def` との違い",
      "意味": "ラムダ式は式（Expression）であり、文（Statement）ではない。また、式は1つしか書けず、複雑な処理は書けない。",
      "サンプルコード": "# ラムダ式では代入やforループなどは書けない"
    },
    {
      "用語名": "高階関数 (Higher-Order Function)",
      "意味": "関数を引数として受け取ったり、関数を戻り値として返したりする関数のこと。ラムダ式は、このような高階関数に渡す小さな関数としてよく使われる。",
      "サンプルコード": "# sorted(), map(), filter() は代表的な高階関数"
    },
    {
      "用語名": "`sorted()` での利用",
      "意味": "リストの並べ替え順を、ラムダ式を使って柔軟に指定できる。",
      "サンプルコード": "pairs = [(1, 'b'), (2, 'a'), (3, 'c')]\n# 各タプルの2番目の要素でソートする\nprint(sorted(pairs, key=lambda p: p[1]))"
    },
    {
      "用語名": "`map()` での利用",
      "意味": "`map()` 関数に、リストの各要素に適用したい処理をラムダ式で渡すことができる。",
      "サンプルコード": "numbers = [1, 2, 3]\ndoubles = list(map(lambda x: x * 2, numbers))\nprint(doubles) # [2, 4, 6]"
    },
    {
      "用語名": "`filter()` での利用",
      "意味": "`filter()` 関数に、要素を絞り込むための条件をラムダ式で渡すことができる。",
      "サンプルコード": "numbers = [1, 2, 3, 4, 5]\nevens = list(filter(lambda x: x % 2 == 0, numbers))\nprint(evens) # [2, 4]"
    },
    {
      "用語名": "即時実行 (Immediately-Invoked)",
      "意味": "ラムダ式を定義すると同時に、その場で実行することもできる（あまり使われないが）。",
      "サンプルコード": "result = (lambda x, y: x + y)(10, 20)\nprint(result) # 30"
    },
    {
      "用語名": "可読性の注意",
      "意味": "ラムダ式は便利だが、複雑な処理を書こうとすると非常に読みにくくなる。その場合は素直に `def` を使って通常の関数を定義するべき。",
      "サンプルコード": "# 悪い例: (lambda x: x if x > 0 else 0)(num)"
    }
,
    {
      "用語名": "assert文 (Assertion)",
      "意味": "「この条件は絶対に真(True)のはずだ」ということを表明（Assert）するための文。もし条件が偽(False)なら、プログラムはAssertionErrorで停止する。",
      "サンプルコード": "age = 20\nassert age >= 0, '年齢がマイナスです'"
    },
    {
      "用語名": "デバッグ目的での利用",
      "意味": "`assert` は主に、プログラムが自分の意図通りに動いているかを確認する、開発中のデバッグ目的で使われる。",
      "サンプルコード": "def calculate_discount(price, rate):\n    assert 0 <= rate <= 1, '割引率は0から1の間のはず'\n    return price * (1 - rate)"
    },
    {
      "用語名": "AssertionError",
      "意味": "`assert`文の条件式がFalseだった場合に発生する例外。",
      "サンプルコード": "x = -1\n# assert x > 0 # ここでAssertionErrorが発生する"
    },
    {
      "用語名": "本番コードでの注意",
      "意味": "Pythonを最適化モード（`-O`オプション）で実行すると、`assert`文はすべて無視される。そのため、ユーザー入力のチェックなど、必ず実行すべき処理には使うべきではない。",
      "サンプルコード": "# python -O my_script.py で実行するとassertは無効になる"
    },
    {
      "用語名": "代入式 (Assignment Expression)",
      "意味": "式の中で変数への代入を可能にする、Python 3.8で導入された新しい構文。見た目がセイウチに似ていることから「セイウチ演算子」とも呼ばれる。",
      "サンプルコード": "# if (n := len(my_list)) > 10:\n#     print(f'リストが長すぎます ({n}個)')"
    },
    {
      "用語名": "セイウチ演算子 (Walrus Operator)",
      "意味": "代入式で使われる `:=` 記号のこと。",
      "サンプルコード": "a := 10 # これ単体では使えない。式の一部として使う"
    },
    {
      "用語名": "`if`文での利用",
      "意味": "条件判定と、その判定で使った値を後で使うための代入を、同時に行うことができる。",
      "サンプルコード": "text = 'hello'\nif (n := len(text)) < 10:\n    print(f'文字列は{n}文字で、10文字未満です')"
    },
    {
      "用語名": "`while`ループでの利用",
      "意味": "ループのたびに値を読み込み、その値でループを続けるか判定する、といった処理を簡潔に書ける。",
      "サンプルコード": "# 従来の書き方\n# line = f.readline()\n# while line:\n#     # ...\n#     line = f.readline()\n\n# 代入式を使った書き方\n# while (line := f.readline()):\n#     # ..."
    },
    {
      "用語名": "冗長性の削減",
      "意味": "代入式を使うことで、同じ関数呼び出しや計算を2回書くといった冗長なコードを避け、よりDRY（Don't Repeat Yourself）なコードにできる。",
      "サンプルコード": "# count = data.get('count', 0)\n# if count > 0:\n# \n# if (count := data.get('count', 0)) > 0:"
    },
    {
      "用語名": "内包表記での利用",
      "意味": "内包表記のフィルタリング条件と、要素の値の両方で同じ計算結果を使いたい場合などに役立つ。",
      "サンプルコード": "def slow_func(x): return x * 2\ndata = [1, 2, 3, -1]\nresults = [y for x in data if (y := slow_func(x)) > 0]"
    }

,
    {
      "用語名": "import",
      "意味": "他のPythonファイル（モジュール）やライブラリを自分のプログラムに読み込んで、その機能を使えるようにするための命令。",
      "サンプルコード": "import math\nprint(math.pi) # mathモジュールの円周率piを使う"
    },
    {
      "用語名": "モジュール (Module)",
      "意味": "Pythonのコードが書かれたファイル（`.py`ファイル）のこと。便利な関数やクラスがまとめられている。",
      "サンプルコード": "# my_module.py というファイルがあれば\nimport my_module"
    },
    {
      "用語名": "ライブラリ (Library)",
      "意味": "複数のモジュールをまとめた、より大きな機能の集まりのこと。一般的に「モジュール」とほぼ同じ意味で使われることも多い。",
      "サンプルコード": "# `pandas`はデータ分析ライブラリ\nimport pandas"
    },
    {
      "用語名": "パッケージ (Package)",
      "意味": "モジュールを階層的に（ディレクトリ構造で）まとめたもの。`.` (ドット) で区切って特定のモジュールをインポートできる。",
      "サンプルコード": "# `urllib`パッケージの中の`request`モジュールを読み込む\nimport urllib.request"
    },
    {
      "用語名": "標準ライブラリ (Standard Library)",
      "意味": "Pythonをインストールしたときに、最初から付属している公式のライブラリ群。`math`, `os`, `datetime`など。",
      "サンプルコード": "import datetime\nprint(datetime.date.today())"
    },
    {
      "用語名": "サードパーティライブラリ (Third-party Library)",
      "意味": "Python公式ではなく、世界中の開発者によって作られ、公開されているライブラリ。`pip`を使ってインストールする必要がある。",
      "サンプルコード": "# `requests`は有名なサードパーティライブラリ\n# pip install requests が必要\nimport requests"
    },
    {
      "用語名": "pip",
      "意味": "サードパーティライブラリをインストール・管理するための公式コマンドラインツール。",
      "サンプルコード": "# コマンドプロンプトやターミナルで実行\npip install pandas"
    },
    {
      "用語名": "`from ... import ...`",
      "意味": "モジュール全体ではなく、その中にある特定の関数やクラスだけを直接使えるようにインポートする方法。",
      "サンプルコード": "from math import pi, sqrt\nprint(pi) # math.と書かなくてよい\nprint(sqrt(4))"
    },
    {
      "用語名": "`import ... as ...`",
      "意味": "インポートしたモジュールや関数に、別名（エイリアス）を付けて使うための方法。長い名前を短くするときによく使われる。",
      "サンプルコード": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt"
    },
    {
      "用語名": "`from ... import *`",
      "意味": "モジュール内のすべての公開されている名前（関数、クラスなど）をインポートする方法。名前の衝突が起きやすいため、通常は非推奨。",
      "サンプルコード": "from math import * # 非推奨\nprint(pi) # math.pi\nprint(sqrt(9)) # math.sqrt"
    },
    {
      "用語名": "名前空間 (Namespace)",
      "意味": "インポートしたときの名前の有効範囲。`import math`なら`math.`という名前空間の中に`pi`などがあり、`from math import pi`なら`pi`が直接使えるようになる。",
      "サンプルコード": "import math\n# math.pi # mathの名前空間にあるpi\n\nfrom random import randint\n# randint # 直接使える"
    },
    {
      "用語名": "requirements.txt",
      "意味": "プロジェクトで利用しているサードパーティライブラリとそのバージョンの一覧を記録しておくためのテキストファイル。",
      "サンプルコード": "# requirements.txt の中身\n# pandas==1.4.2\n# numpy==1.22.3"
    },
    {
      "用語名": "`pip install -r requirements.txt`",
      "意味": "`requirements.txt`に書かれたライブラリを、すべてまとめて一括でインストールするためのコマンド。",
      "サンプルコード": "# コマンドプロンプトで実行\npip install -r requirements.txt"
    },
    {
      "用語名": "osモジュール",
      "意味": "OS（オペレーティングシステム）を操作するための機能を提供する標準ライブラリ。ファイルの操作、ディレクトリの作成などで使う。",
      "サンプルコード": "import os\nprint(os.getcwd()) # 現在のディレクトリを取得"
    },
    {
      "用語名": "datetimeモジュール",
      "意味": "日付や時刻を扱うための機能を提供する標準ライブラリ。",
      "サンプルコード": "import datetime\nnow = datetime.datetime.now()\nprint(now.strftime('%Y-%m-%d %H:%M:%S'))"
    },
    {
      "用語名": "jsonモジュール",
      "意味": "JSON形式のデータを扱うための標準ライブラリ。APIとの通信などでよく使う。",
      "サンプルコード": "import json\ndata = {'name': 'Taro'}\njson_str = json.dumps(data)\nprint(json_str)"
    }
,
    {
      "用語名": "ファイルI/O (Input/Output)",
      "意味": "プログラムがファイルからデータを読み込んだり（Input）、ファイルにデータを書き込んだり（Output）すること。",
      "サンプルコード": "# I/OはInput/Outputの略"
    },
    {
      "用語名": "`open()` 関数",
      "意味": "ファイルを操作するために「開く」組み込み関数。ファイルパスとモードを指定する。",
      "サンプルコード": "f = open('test.txt', 'r', encoding='utf-8')"
    },
    {
      "用語名": "`with`文",
      "意味": "ファイルなどを開いた後に、処理が終わったら自動的に閉じてくれる便利な構文。ファイルの操作では必ず使うべきとされている。",
      "サンプルコード": "with open('test.txt', 'r') as f:\n    # このブロック内でファイル操作を行う\n    pass # ブロックを抜けると自動でファイルが閉じる"
    },
    {
      "用語名": "ファイルモード (`'r'`, `'w'`, `'a'`)",
      "意味": "ファイルを開く目的を指定する。`'r'`は読み込み、`'w'`は上書き書き込み、`'a'`は追記。",
      "サンプルコード": "with open('log.txt', 'a') as f:\n    f.write('New log entry\\n')"
    },
    {
      "用語名": "エンコーディング (Encoding)",
      "意味": "文字をコンピュータが理解できるバイト列に変換するときのルール。日本語を扱う場合は`'utf-8'`を指定するのが一般的。",
      "サンプルコード": "with open('data.txt', 'r', encoding='utf-8') as f:\n    content = f.read()"
    },
    {
      "用語名": "`.read()` メソッド",
      "意味": "ファイルの内容をすべて読み込んで、1つの文字列として返す。",
      "サンプルコード": "with open('story.txt', 'r', encoding='utf-8') as f:\n    all_text = f.read()"
    },
    {
      "用語名": "`.readline()` メソッド",
      "意味": "ファイルから1行だけ読み込んで文字列として返す。ファイルの最後まで到達すると空文字列を返す。",
      "サンプルコード": "with open('list.txt', 'r', encoding='utf-8') as f:\n    first_line = f.readline()"
    },
    {
      "用語名": "`.readlines()` メソッド",
      "意味": "ファイルの内容を1行ずつ読み込み、各行を要素とするリストとして返す。",
      "サンプルコード": "with open('list.txt', 'r', encoding='utf-8') as f:\n    all_lines = f.readlines()"
    },
    {
      "用語名": "`.write()` メソッド",
      "意味": "ファイルに文字列を書き込む。改行は自動で入らないので、必要なら`\\n`を含める。",
      "サンプルコード": "with open('output.txt', 'w', encoding='utf-8') as f:\n    f.write('Hello, Python!\\n')"
    },
    {
      "用語名": "絶対パス (Absolute Path)",
      "意味": "コンピュータのルートディレクトリ（一番上の階層）から目的のファイルまでの完全な経路。`C:\\Users\\...` や `/home/user/...` など。",
      "サンプルコード": "# with open('C:\\Users\\Taro\\Documents\\file.txt', 'r')"
    },
    {
      "用語名": "相対パス (Relative Path)",
      "意味": "現在作業しているディレクトリ（カレントディレクトリ）から目的のファイルまでの経路。",
      "サンプルコード": "# `my_script.py`と同じ階層にある`data.txt`を開く\nwith open('data.txt', 'r')"
    },
    {
      "用語名": "pathlibモジュール",
      "意味": "ファイルパスをオブジェクトとして、より直感的かつ安全に操作するための標準ライブラリ。OSの違い（Windowsの`\\`とMac/Linuxの`/`）を吸収してくれる。",
      "サンプルコード": "from pathlib import Path\n\ndata_file = Path('data') / 'sales.csv'\nif data_file.exists():\n    print('ファイルが見つかりました')"
    },
    {
      "用語名": "csvモジュール",
      "意味": "CSV（カンマ区切り）ファイルを読み書きするための標準ライブラリ。",
      "サンプルコード": "import csv\nwith open('data.csv', 'r') as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print(row)"
    }
,
    {
      "用語名": "Webスクレイピング (Web Scraping)",
      "意味": "Webサイトから自動的に情報を収集する技術。`requests`でWebサイトのHTMLを取得し、`BeautifulSoup`で解析するのが一般的。",
      "サンプルコード": "import requests\nfrom bs4 import BeautifulSoup\n\nres = requests.get('https://example.com')\nsoup = BeautifulSoup(res.text, 'html.parser')"
    },
    {
      "用語名": "requestsライブラリ",
      "意味": "PythonでHTTP通信を簡単に行うための、非常に人気のあるサードパーティライブラリ。Webサイトの情報を取得するのに使う。",
      "サンプルコード": "import requests\nresponse = requests.get('https://api.github.com')"
    },
    {
      "用語名": "BeautifulSoupライブラリ",
      "意味": "HTMLやXMLのデータから、目的の情報（特定のタグのテキストなど）を簡単に見つけ出して抽出するためのライブラリ。",
      "サンプルコード": "# from bs4 import BeautifulSoup\n# soup.find('h1').text # <h1>タグのテキストを取得"
    },
    {
      "用語名": "API (Application Programming Interface)",
      "意味": "ソフトウェアやWebサービスが、外部のプログラムから機能を利用できるように提供している「窓口」や「命令セット」。JSON形式でデータをやり取りすることが多い。",
      "サンプルコード": "# 天気予報API、地図API、翻訳APIなどがある"
    },
    {
      "用語名": "Excel操作 (openpyxl / pandas)",
      "意味": "PythonでExcelファイルを読み書きすること。`openpyxl`はセル単位の詳細な操作、`pandas`は表データ全体の高度な分析や操作に向いている。",
      "サンプルコード": "import pandas as pd\ndf = pd.read_excel('sales.xlsx')\nprint(df.head())"
    },
    {
      "用語名": "pandasライブラリ",
      "意味": "ExcelやCSVなどの表形式データを効率的に扱うための、データ分析の必須ライブラリ。DataFrameという強力なデータ構造を持つ。",
      "サンプルコード": "import pandas as pd\ndf = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\ndf.to_csv('output.csv')"
    },
    {
      "用語名": "GUIオートメーション (pyautogui)",
      "意味": "キーボードやマウスの操作をプログラムで自動化すること。`pyautogui`ライブラリを使えば、画面の特定の位置をクリックしたり、文字を入力したりできる。",
      "サンプルコード": "import pyautogui\n\n# 画面の(100, 200)の位置に移動してクリック\npyautogui.moveTo(100, 200, duration=1)\npyautogui.click()"
    },
    {
      "用語名": "Seleniumライブラリ",
      "意味": "Webブラウザの操作を自動化するためのライブラリ。ログインが必要なサイトや、ボタンをクリックして情報を表示するようなサイトのスクレイピングに使う。",
      "サンプルコード": "# from selenium import webdriver\n# driver = webdriver.Chrome()\n# driver.get('https://example.com')"
    },
    {
      "用語名": "タスクスケジューリング",
      "意味": "作成したPythonスクリプトを、毎日決まった時刻や、毎週特定の曜日など、定期的に自動実行するように設定すること。",
      "サンプルコード": "# OSの機能（Windowsのタスクスケジューラ, Mac/Linuxのcron）や、\n# Pythonの`schedule`ライブラリを使う"
    },
    {
      "用語名": "shutilモジュール",
      "意味": "ファイルのコピー、移動、削除など、より高度なファイル操作を行うための標準ライブラリ。",
      "サンプルコード": "import shutil\n\nshutil.copy('original.txt', 'backup.txt')\nshutil.move('old_dir', 'new_dir')"
    },
    {
      "用語名": "メール送信 (smtplib)",
      "意味": "Pythonでメールを自動送信するための標準ライブラリ。日次レポートの送信などを自動化できる。",
      "サンプルコード": "import smtplib\n# サーバーに接続し、メールを送信するコードを書く"
    },
    {
      "用語名": "画像処理 (Pillow)",
      "意味": "画像のサイズ変更、切り抜き、フィルター加工などを自動化すること。`Pillow` (PIL) ライブラリが広く使われている。",
      "サンプルコード": "from PIL import Image\n\nimg = Image.open('photo.jpg')\nresized_img = img.resize((200, 200))\nresized_img.save('photo_small.jpg')"
    }
,
    {
      "用語名": "データベース (Database, DB)",
      "意味": "大量のデータを、整理された形で効率的に保存・管理するためのシステム。顧客リストや商品情報などを格納する「巨大な電子台帳」のようなもの。",
      "サンプルコード": "# Pythonからデータベースに接続してデータを操作する"
    },
    {
      "用語名": "RDBMS (リレーショナルデータベース)",
      "意味": "データをExcelのような「表（テーブル）」の形式で管理する、最も一般的なデータベース。行と列で構成される。",
      "サンプルコード": "# 代表例: MySQL, PostgreSQL, SQLite"
    },
    {
      "用語名": "SQL (Structured Query Language)",
      "意味": "RDBMSを操作するための専門言語。「このテーブルからこの条件のデータを取り出せ」といった命令をSQLで書く。",
      "サンプルコード": "SELECT name, age FROM users WHERE age > 20;"
    },
    {
      "用語名": "CRUD (クラッド)",
      "意味": "データベース操作の基本である「作成(Create)」「読み取り(Read)」「更新(Update)」「削除(Delete)」の4つの頭文字をとった言葉。",
      "サンプルコード": "# SQLのINSERT, SELECT, UPDATE, DELETEがCRUDに対応する"
    },
    {
      "用語名": "テーブル / カラム / レコード",
      "意味": "テーブルは「表」、カラムは「列（項目名）」、レコードは「行（一件分のデータ）」のこと。",
      "サンプルコード": "# `users`テーブルの`name`カラムから1レコードを取得"
    },
    {
      "用語名": "主キー (Primary Key)",
      "意味": "テーブル内の各レコードを、重複なく一意に識別するための特別なカラム。会員番号やIDなどが使われる。",
      "サンプルコード": "# 主キーがあることで、特定の1件のデータを確実に更新・削除できる"
    },
    {
      "用語名": "SQLite",
      "意味": "Pythonに標準で付属している、ファイルベースの軽量なデータベース。サーバー不要で手軽に使えるため、小規模なアプリや学習用に最適。",
      "サンプルコード": "import sqlite3\n\nconn = sqlite3.connect('example.db')\n# これだけでデータベースファイルが作られる"
    },
    {
      "用語名": "ORM (Object-Relational Mapping)",
      "意味": "SQLを直接書かなくても、Pythonのオブジェクトを操作するだけで、データベースを自動的に操作してくれる仕組み。コードがPythonらしくなり、安全性が高まる。",
      "サンプルコード": "# SQL: SELECT * FROM users WHERE id=1\n# ORM: user = User.objects.get(id=1)"
    },
    {
      "用語名": "SQLAlchemy / Django ORM",
      "意味": "Pythonで最も有名なORMライブラリ。SQLAlchemyは汎用的、Django ORMはWebフレームワークDjangoに組み込まれている。",
      "サンプルコード": "# from sqlalchemy import create_engine"
    },
    {
      "用語名": "Webアプリケーション",
      "意味": "Webブラウザを通じて利用するアプリケーションのこと。SNSやネット通販サイトなど、普段インターネットで見ているものの多くがこれにあたる。",
      "サンプルコード": "# Pythonは、この裏側（サーバーサイド）で動くプログラムを作るのが得意"
    },
    {
      "用語名": "バックエンド / フロントエンド",
      "意味": "バックエンドは、サーバー側で動くデータ処理など「ユーザーに見えない部分」（Pythonの担当）。フロントエンドは、ブラウザで表示される見た目や動きの部分（HTML, CSS, JavaScriptの担当）。",
      "サンプルコード": "# Pythonはバックエンド言語"
    },
    {
      "用語名": "Webフレームワーク",
      "意味": "Webアプリケーション開発を効率的に行うための「骨組み」や「道具セット」。URLの処理やHTMLの生成などを簡単にしてくれる。",
      "サンプルコード": "# Pythonの有名フレームワーク: Django, Flask"
    },
    {
      "用語名": "Django (ジャンゴ)",
      "意味": "フルスタックなWebフレームワーク。「全部入り」で、大規模なWebアプリ開発に必要な機能（管理画面、ORMなど）が一通り揃っている。",
      "サンプルコード": "# `python manage.py runserver` で開発サーバーを起動"
    },
    {
      "用語名": "Flask (フラスク)",
      "意味": "マイクロなWebフレームワーク。最小限の機能だけを提供し、必要に応じて機能を追加していくスタイル。シンプルで学習しやすい。",
      "サンプルコード": "from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return 'Hello, World!'"
    },
    {
      "用語名": "ルーティング (Routing)",
      "意味": "特定のURL（例: `/users/1`）へのアクセスが来たときに、どのPythonの関数を呼び出すかを対応付ける仕組み。",
      "サンプルコード": "@app.route('/profile/<username>')"
    },
    {
      "用語名": "リクエスト / レスポンス",
      "意味": "Webの基本動作。ブラウザがサーバーに「このページをください」とお願い(リクエスト)し、サーバーが「はい、どうぞ」とHTMLなどを返す(レスポンス)こと。",
      "サンプルコード": "# Flaskではrequestオブジェクトでリクエスト情報を取得する"
    },
    {
      "用語名": "HTTPメソッド (GET, POST)",
      "意味": "リクエストの種類。GETは「データをください」という要求、POSTは「このデータを登録・送信します」という要求。",
      "サンプルコード": "@app.route('/login', methods=['GET', 'POST'])"
    },
    {
      "用語名": "テンプレートエンジン (Jinja2)",
      "意味": "HTMLの雛形（テンプレート）に、Pythonから渡したデータを埋め込んで、動的にWebページを生成する仕組み。",
      "サンプルコード": "<h1>こんにちは、{{ name }}さん！</h1>\n# {{ name }} の部分がPythonの変数で置き換えられる"
    },
    {
      "用語名": "WSGI (Web Server Gateway Interface)",
      "意味": "PythonのWebアプリケーションと、Webサーバー（Apache, Nginxなど）を接続するための標準的なルール（インターフェース）。",
      "サンプルコード": "# GunicornやuWSGIといったWSGIサーバーと組み合わせて本番運用する"
    }
,
    {
      "用語名": "「Pythonではすべてがオブジェクト」",
      "意味": "数値、文字列、関数、クラス、モジュールなど、Pythonで扱うデータはすべて「オブジェクト」という統一された形式で扱われるという基本思想。",
      "サンプルコード": "def my_func(): pass\nprint(my_func.__name__) # 関数も属性を持つオブジェクト"
    },
    {
      "用語名": "特殊メソッド (マジックメソッド)",
      "意味": "クラスに定義することで、Pythonの特定の構文（`+`演算子や`len()`関数など）の振る舞いをカスタマイズできる、`__`で囲まれたメソッド群。",
      "サンプルコード": "# 例: `__add__`を定義すると、`+`演算子が使えるようになる"
    },
    {
      "用語名": "`__str__` / `__repr__`",
      "意味": "`str()`や`print()`で表示される、人間にとって分かりやすい文字列を返すのが`__str__`。`repr()`で表示される、開発者向けの正確な表現を返すのが`__repr__`。",
      "サンプルコード": "class Person:\n    def __repr__(self):\n        return 'Person()'"
    },
    {
      "用語名": "`__len__`",
      "意味": "そのオブジェクトに対して`len()`関数が使われたときに呼び出される。要素数を返すように実装する。",
      "サンプルコード": "class MyList:\n    def __len__(self):\n        return 10\n\nprint(len(MyList())) # 10"
    },
    {
      "用語名": "`__getitem__` / `__setitem__`",
      "意味": "`obj[key]`のような角括弧でのアクセスを可能にする。`__getitem__`は値の取得、`__setitem__`は値の設定で呼ばれる。",
      "サンプルコード": "class MyDict:\n    def __getitem__(self, key):\n        return f'Value for {key}'\n\nd = MyDict()\nprint(d['test']) # 'Value for test'"
    },
    {
      "用語名": "`__iter__` / `__next__`",
      "意味": "オブジェクトを`for`ループで使えるようにするためのメソッド（イテレータプロトコル）。`__iter__`がイテレータ自身を返し、`__next__`が次の要素を返す。",
      "サンプルコード": "# ジェネレータを使えばこれらを自動で実装できる"
    },
    {
      "用語名": "`__call__`",
      "意味": "インスタンスそのものを、まるで関数のように`()`を付けて呼び出せるようにする。",
      "サンプルコード": "class Adder:\n    def __call__(self, x, y):\n        return x + y\n\nadd = Adder()\nprint(add(3, 5)) # インスタンスを関数として呼び出す"
    },
    {
      "用語名": "`__enter__` / `__exit__`",
      "意味": "`with`文で使えるオブジェクト（コンテキストマネージャ）を定義する。`__enter__`で前処理、`__exit__`で後処理（エラーでも必ず呼ばれる）を行う。",
      "サンプルコード": "class Timer:\n    def __enter__(self): pass\n    def __exit__(self, exc_type, exc_val, exc_tb): pass"
    },
    {
      "用語名": "演算子オーバーロード",
      "意味": "`__add__`, `__sub__`, `__mul__`などを定義して、`+`, `-`, `*`といった演算子を自作クラスで使えるようにすること。",
      "サンプルコード": "class Vector:\n    def __add__(self, other):\n        # ベクトル同士の足し算を実装\n        pass"
    },
    {
      "用語名": "`__eq__` / `__ne__`",
      "意味": "自作クラスのインスタンス同士を`==` (等価) や`!=` (不等)で比較したときのルールを定義する。",
      "サンプルコード": "class Person:\n    def __eq__(self, other):\n        return self.name == other.name"
    },
    {
      "用語名": "プロパティ (`@property`)",
      "意味": "メソッドを、インスタンス変数（属性）のように`()`なしでアクセスできるようにするデコレータ。値の取得ルールを複雑にしたい場合に便利。",
      "サンプルコード": "class Circle:\n    @property\n    def area(self):\n        return self.radius ** 2 * 3.14"
    },
    {
      "用語名": "ディスクリプタ (Descriptor)",
      "意味": "属性へのアクセス（取得、設定、削除）をフックして、独自の動作を定義するための高度な仕組み。`@property`もディスクリプタを使って実現されている。",
      "サンプルコード": "# `__get__`, `__set__`, `__delete__`メソッドを持つクラス"
    },
    {
      "用語名": "ダックタイピング (Duck Typing)",
      "意味": "「アヒルのように歩き、アヒルのように鳴くなら、それはアヒルだ」という考え方。オブジェクトの「型」が何かではなく、どんな「振る舞い（メソッド）」を持つかを重視するPythonの思想。",
      "サンプルコード": "# `len()`関数は、オブジェクトが何型か気にせず、`__len__`メソッドを持つものなら何でも受け入れる"
    },
    {
      "用語名": "抽象基底クラス (ABC)",
      "意味": "`abc`モジュールを使って作る、インスタンス化できない「設計図専用」のクラス。これを継承する子クラスに、特定のメソッドの実装を強制できる。",
      "サンプルコード": "from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self): pass"
    },
    {
      "用語名": "ガベージコレクション (GC)",
      "意味": "プログラム中で誰からも参照されなくなった（不要になった）オブジェクトを、Pythonが自動的に検知してメモリからお掃除してくれる仕組み。",
      "サンプルコード": "# プログラマーはメモリ管理をあまり意識しなくてよい"
    },
    {
      "用語名": "参照カウント",
      "意味": "各オブジェクトが、いくつの変数から参照されているかを数えておく仕組み。カウントが0になったら、そのオブジェクトは不要だと判断され、メモリから解放される。",
      "サンプルコード": "import sys\na = []\nprint(sys.getrefcount(a)) # 2 (aとgetrefcountの引数から)"
    },
    {
      "用語名": "`__slots__`",
      "意味": "クラスで定義するインスタンス変数の名前をあらかじめ固定することで、メモリ使用量を節約し、属性へのアクセスを高速化する仕組み。",
      "サンプルコード": "class Point:\n    __slots__ = ['x', 'y']"
    },
    {
      "用語名": "メタクラス (Metaclass)",
      "意味": "「クラスを作るためのクラス」。クラス定義自体をカスタマイズするための、Pythonの最も高度なトピックの一つ。",
      "サンプルコード": "class MyMeta(type):\n    pass\n\nclass MyClass(metaclass=MyMeta):\n    pass"
    },
    {
      "用語名": "デザインパターン",
      "意味": "オブジェクト指向プログラミングで頻繁に現れる問題と、その典型的な解決策（設計パターン）をカタログ化したもの。",
      "サンプルコード": "# 例：シングルトン、ファクトリ、デコレータ、オブザーバーなど"
    },
    {
      "用語名": "AI (人工知能)",
      "意味": "人間の知的な振る舞い（学習、推論、判断など）をコンピュータで模倣する技術の総称。",
      "サンプルコード": "# AIは、ゲームのキャラクターの動きから、お掃除ロボットまで幅広く使われている"
    },
    {
      "用語名": "機械学習 (Machine Learning)",
      "意味": "AIの一分野。大量のデータをコンピュータに与え、データに潜むパターンやルールを自動的に学習させる技術。",
      "サンプルコード": "# 例：たくさんの犬の画像を見せて、「犬とは何か」を学習させる"
    },
    {
      "用語名": "ディープラーニング (Deep Learning)",
      "意味": "機械学習の一手法で、人間の脳の神経回路（ニューラルネットワーク）を模した複雑なモデルを使う。特に画像認識や自然言語処理で高い性能を発揮する。",
      "サンプルコード": "# 近年のAI技術のブレークスルーの中心的な技術"
    },
    {
      "用語名": "モデル (Model)",
      "意味": "機械学習によって作られた、データから何かを予測・判断するための「AIの脳みそ」のようなもの。学習済みのルールやパターンの塊。",
      "サンプルコード": "model.predict(new_image) # 学習済みモデルで新しい画像を予測"
    },
    {
      "用語名": "学習 / 訓練 (Training)",
      "意味": "データセットを使って、モデルを賢くしていくプロセス。たくさんの問題と答えを見せて、モデルに正解のパターンを覚えさせていくイメージ。",
      "サンプルコード": "model.fit(X_train, y_train) # 訓練データでモデルを学習させる"
    },
    {
      "用語名": "推論 (Inference)",
      "意味": "学習済みのモデルを使って、未知の新しいデータに対して予測や分類を行うこと。AIを実際に「使う」段階。",
      "サンプルコード": "result = model.predict(test_data) # テストデータで推論を行う"
    },
    {
      "用語名": "データセット (Dataset)",
      "意味": "機械学習モデルの学習や評価に使う、大量のデータの集まり。",
      "サンプルコード": "# 例：手書き数字の画像データセット「MNIST」"
    },
    {
      "用語名": "教師あり学習",
      "意味": "「問題（データ）」と「正解（ラベル）」がペアになったデータセットを使って学習する手法。犬の画像に「犬」というラベルを付けて学習させるなど。",
      "サンプルコード": "# 画像認識、迷惑メールフィルタなどで使われる"
    },
    {
      "用語名": "教師なし学習",
      "意味": "正解ラベルがないデータから、データそのものの構造やパターンを見つけ出す手法。顧客のグループ分け（クラスタリング）など。",
      "サンプルコード": "# データの自動的な分類や、異常検知などで使われる"
    },
    {
      "用語名": "画像認識",
      "意味": "画像や動画に写っているものが何か（人、車、猫など）を識別するAI技術。",
      "サンプルコード": "# スマートフォンの顔認証や、自動運転車の物体検出などに活用"
    },
    {
      "用語名": "自然言語処理 (NLP)",
      "意味": "人間が日常的に使っている言葉（自然言語）を、コンピュータに理解させたり生成させたりする技術。",
      "サンプルコード": "# 機械翻訳、チャットボット、文章の要約などに活用"
    },
    {
      "用語名": "生成AI (Generative AI)",
      "意味": "学習したデータをもとに、新しい文章、画像、音楽、コードなどをゼロから創り出すAIの総称。",
      "サンプルコード": "# ChatGPTやStable Diffusionは代表的な生成AI"
    },
    {
      "用語名": "大規模言語モデル (LLM)",
      "意味": "インターネット上の膨大なテキストデータで学習した、非常に巨大で高性能な自然言語処理モデル。人間のように自然な対話ができる。",
      "サンプルコード": "# LLMはLarge Language Modelの略。ChatGPTの頭脳部分。"
    },
    {
      "用語名": "API (Application Programming Interface)",
      "意味": "外部のプログラムから、AIモデルなどの機能を利用するための「窓口」。APIを使えば、自分でAIを作らなくても高度な機能を利用できる。",
      "サンプルコード": "# OpenAI APIを使えば、自分のアプリにChatGPTの機能を組み込める"
    },
    {
      "用語名": "TensorFlow / Keras",
      "意味": "Googleが中心となって開発している、ディープラーニングのための代表的なライブラリ。KerasはTensorFlowを簡単に使えるようにしたもの。",
      "サンプルコード": "import tensorflow as tf"
    },
    {
      "用語名": "PyTorch",
      "意味": "Meta社（旧Facebook）が中心となって開発している、TensorFlowと並ぶ人気のディープラーニングライブラリ。研究分野で特に人気が高い。",
      "サンプルコード": "import torch"
    },
    {
      "用語名": "scikit-learn",
      "意味": "伝統的な機械学習（ディープラーニング以外）のアルゴリズムを幅広くカバーしている、非常に使いやすいライブラリ。まずはここから始める人が多い。",
      "サンプルコード": "from sklearn.model_selection import train_test_split"
    },
    {
      "用語名": "Hugging Face Transformers",
      "意味": "最新の自然言語処理モデル（LLMなど）を、数行のコードで簡単にダウンロードして利用できる、非常に人気のライブラリ。",
      "サンプルコード": "from transformers import pipeline\n\nclassifier = pipeline('sentiment-analysis')\nclassifier('I love this!')"
    },
    {
      "用語名": "Stable Diffusion",
      "意味": "「海辺を走る馬」のようなテキスト（プロンプト）を入力するだけで、非常に高品質な画像を生成できる、オープンソースの画像生成AI。",
      "サンプルコード": "# Pythonライブラリ `diffusers` を使ってプログラムから操作できる"
    },
    {
      "用語名": "GPU",
      "意味": "本来は画像処理用のハイスペックな半導体だが、大量の計算を並行して行うのが得意なため、ディープラーニングの学習を高速化するために必須となっている。",
      "サンプルコード": "# Google Colabなどのクラウドサービスで、無料でGPUを利用できる"
    }
,
    {
      "用語名": "Webスクレイピング",
      "意味": "Webサイトから、必要な情報だけをプログラムで自動的に収集・抽出する技術。",
      "サンプルコード": "# 株価、天気予報、商品価格などのデータを定期的に集めるのに使う"
    },
    {
      "用語名": "HTTPリクエスト",
      "意味": "自分のPC（クライアント）からWebサイトのサーバーへ、「このページの情報が欲しい」とお願い（リクエスト）を送ること。",
      "サンプルコード": "import requests\nresponse = requests.get('https://example.com')"
    },
    {
      "用語名": "HTML",
      "意味": "Webページの構造を記述するための言語。見出し、段落、リンクなどが「タグ」で囲まれており、スクレイピングの主な解析対象となる。",
      "サンプルコード": "<h1>これは見出しです</h1>\n<p>これは段落です。</p>\n<a href=\"#\">リンク</a>"
    },
    {
      "用語名": "CSSセレクタ",
      "意味": "HTMLの中から、特定の要素（例：「classがtitleの見出し」など）を指定するための書き方。目的の情報をピンポイントで抽出するのに使う。",
      "サンプルコード": "# `soup.select('#main-title')` -> idが'main-title'の要素を選択"
    },
    {
      "用語名": "静的サイト",
      "意味": "誰がいつアクセスしても同じHTMLが表示される、昔ながらのWebサイト。requestsとBeautifulSoupだけで簡単にスクレイピングできることが多い。",
      "サンプルコード": "# ニュース記事やブログなど"
    },
    {
      "用語名": "動的サイト",
      "意味": "JavaScriptを使って、ページが表示された後から内容が読み込まれたり変化したりするサイト。スクレイピングにはSeleniumなどの工夫が必要。",
      "サンプルコード": "# SNSの無限スクロールや、地図サイトなど"
    },
    {
      "用語名": "requestsライブラリ",
      "意味": "PythonでHTTPリクエストを非常に簡単に送ることができる、事実上の標準ライブラリ。WebページのHTMLを取得する第一歩。",
      "サンプルコード": "import requests\n\nres = requests.get('https://www.python.org')\nprint(res.status_code) # 200 (成功) ならOK"
    },
    {
      "用語名": "BeautifulSoupライブラリ",
      "意味": "requestsで取得したHTMLの文字列を、プログラムで扱いやすいように解析（パース）し、CSSセレクタなどで簡単に情報を抽出できるようにしてくれるライブラリ。",
      "サンプルコード": "from bs4 import BeautifulSoup\n\nsoup = BeautifulSoup(res.text, 'html.parser')\nprint(soup.find('h1').text)"
    },
    {
      "用語名": "Seleniumライブラリ",
      "意味": "プログラムでWebブラウザ（Chromeなど）を自動操作するためのライブラリ。人間が操作するのと同じように、ボタンをクリックしたり文字を入力したりできる。",
      "サンプルコード": "from selenium import webdriver\n\ndriver = webdriver.Chrome()\ndriver.get('https://example.com')"
    },
    {
      "用語名": "ヘッドレスブラウザ",
      "意味": "画面表示を行わずに、裏側で動作するブラウザ。Seleniumをヘッドレスモードで動かすと、画面がなくても自動操作ができ、サーバー上での定期実行などに便利。",
      "サンプルコード": "options.add_argument('--headless')\ndriver = webdriver.Chrome(options=options)"
    },
    {
      "用語名": "robots.txt",
      "意味": "Webサイトの運営者が、プログラム（クローラー）に対して「このページにはアクセスしないでください」という意思表示をするためのファイル。スクレイピング前には必ず確認するべきマナー。",
      "サンプルコード": "# `https://example.com/robots.txt` にアクセスして確認する"
    },
    {
      "用語名": "利用規約",
      "意味": "Webサイトの利用に関するルール。サイトによってはスクレイピングを明確に禁止している場合があるため、確認が必要。",
      "サンプルコード": "# サイトのフッターなどにある「利用規約」や「Terms of Service」を読む"
    },
    {
      "用語名": "アクセス間隔（ウェイト）",
      "意味": "Webサーバーに過度な負荷をかけないように、リクエストとリクエストの間に数秒の待ち時間を入れること。`time.sleep()`を使う。",
      "サンプルコード": "import time\n\nfor url in urls:\n    res = requests.get(url)\n    # ...処理...\n    time.sleep(1) # 1秒待つ"
    },
    {
      "用語名": "ユーザーエージェント",
      "意味": "クライアントが「私はどんなブラウザです」とサーバーに伝えるための情報。スクレイピング時にこれを設定しないと、プログラムからのアクセスだとバレて弾かれることがある。",
      "サンプルコード": "headers = {'User-Agent': 'Mozilla/5.0 ...'}\nres = requests.get(url, headers=headers)"
    },
    {
      "用語名": "IP BAN",
      "意味": "短時間にあまりにも多くのアクセスを行うと、サーバー側からあなたのIPアドレスからのアクセスを拒否（BAN）されてしまうこと。節度あるアクセスが重要。",
      "サンプルコード": "# BANされると、そのサイトに一切アクセスできなくなることがある"
    },
    {
      "用語名": "XPath",
      "意味": "HTML/XML文書の中から特定の要素を指定するための、もう一つの主要な方法。CSSセレクタよりも複雑な指定ができる。",
      "サンプルコード": "# `tree.xpath('//h1/text()')` -> すべてのh1タグのテキストを取得"
    },
    {
      "用語名": "パーサー (Parser)",
      "意味": "HTMLのような特定の構造を持ったテキストを解析し、プログラムが扱いやすいデータ構造（ツリー構造など）に変換するプログラム。BeautifulSoupは内部でlxmlなどを使う。",
      "サンプルコード": "soup = BeautifulSoup(html_doc, 'lxml')"
    },
    {
      "用語名": "クッキー (Cookie)",
      "意味": "ログイン状態などを保持するために、Webサーバーがブラウザに保存させる小さなデータ。ログイン後のページをスクレイピングする際に必要になることがある。",
      "サンプルコード": "# requestsではセッションオブジェクトを使うとクッキーを自動管理できる"
    },
    {
      "用語名": "セッション (Session)",
      "意味": "一連の通信（ログインしてからログアウトするまでなど）を維持するための仕組み。`requests.Session()`を使うと、ログイン状態を保ったまま複数のページにアクセスできる。",
      "サンプルコード": "session = requests.Session()\nsession.post(login_url, data=payload)"
    },
    {
      "用語名": "Scrapy (スクレイピー)",
      "意味": "スクレイピングのためにより大規模で本格的なフレームワーク。複数のページを効率的に巡回（クローリング）し、データを抽出して保存する一連の流れを体系的に作れる。",
      "サンプルコード": "# 小さなスクリプトではなく、一つのプロジェクトとして開発するイメージ"
    }]